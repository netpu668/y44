import logging
import uuid
import datetime
import requests # áŸá˜áŸ’ášá¶á”áŸ‹ API requests
import io # áŸá˜áŸ’ášá¶á”áŸ‹áŠáŸ†áá¾ášá€á¶ášášá¼á”á—á¶á–

from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, ReplyKeyboardMarkup, KeyboardButton, ReplyKeyboardRemove
from telegram.ext import Application, CommandHandler, CallbackQueryHandler, MessageHandler, filters, ConversationHandler, ContextTypes, JobQueue
from telegram.error import TelegramError, BadRequest

# á”á¾á€á€á¶áš Log
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO
)
logger = logging.getLogger(__name__)

# --- States áŸá˜áŸ’ášá¶á”áŸ‹ ConversationHandler ---
ADD_PLATFORM_NAME = 1
ADD_SERVICE_PLATFORM = 2
ADD_SERVICE_NAME = 3
ADD_SERVICE_PRICE = 4
ADD_SMM_SERVICE_ID = 14 

RECEIVE_LINK = 5
RECEIVE_QUANTITY = 6
CONFIRM_ORDER_AND_PAY = 8
RENAME_PLATFORM_OLD_NAME = 10
RENAME_PLATFORM_NEW_NAME = 11
ASK_USER_ID_FOR_DEPOSIT = 12
ASK_AMOUNT_FOR_DEPOSIT = 13
DEPOSIT_AMOUNT = 20
AWAIT_MD5_VERIFICATION = 21 
DELETE_PLATFORM_NAME = 22 
CONFIRM_DELETE_PLATFORM = 23 
CONFIRM_DELETE_ALL_SERVICES = 9 


# --- SMM Panel API Configuration ---
SMM_API_CONFIG = {
    "SMM_API_URL": "https://smeysmm.com/api/v2",
    "SMM_API_KEY": "f18f1c0c27c9eb3907ca64698ecb764f"
}

# --- á‘á·á“áŸ’á“á“áŸá™ (áŸá˜áŸ’ášá¶á”áŸ‹ Admin Panel) ---
services_data = {
    "Facebook": [
        {"id": "fb_likes", "name": "Facebook Page Likes + Followers", "price_per_k": 5.0, "smm_service_id": 101},
        {"id": "fb_followers", "name": "Facebook Followers", "price_per_k": 10.0, "smm_service_id": 102},
    ],
    "TikTok": [
        {"id": "tt_likes", "name": "TikTok Likes", "price_per_k": 4.0, "smm_service_id": 201},
    ],
    "YouTube": [
        {"id": "yt_views", "name": "YouTube Views", "price_per_k": 6.0, "smm_service_id": 301},
    ],
    "Twitter": [],
    "Telegram": [],
    "Instagram": [],
}

# áŸá˜áŸ’ášá¶á”áŸ‹ Admin ááŸ‚á”áŸ‰á»ááŸ’ááŸ„áŸ‡
ADMIN_USER_IDS = [1380299845]

# === [á€á¶ášá€áŸ†áááŸ‹áŸáŸ†áá¶á“áŸ‹] ===
TELEGRAM_GROUP_ID = -1002885884014 # Your actual group ID
DEPOSIT_CONFIRMATION_CHAT_ID = 1380299845 # Chat ID áŠáŸ‚á› Admin á“á¹á„á‘á‘á½á›á”á¶á“áŸá¶ášá”á‰áŸ’á‡á¶á€áŸ‹á€á¶ášáŠá¶á€áŸ‹á”áŸ’ášá¶á€áŸ‹

# Bakong API Token áŸá˜áŸ’ášá¶á”áŸ‹ MD5 Check (á™á€á–á¸ qrcode.php)
BAKONG_API_TOKEN = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJkYXRhIjp7ImlkIjoiOWZiOWE1YTViNTk1NDVhNCJ9LCJpYXQiOjE3NTAyMDk3NDAsImV4cCI6MTc1Nzk4NTc0MH0.mmyjGfKG7dHKhkFMAwwsBO6peIMd5RNR2VlmvVoUJ2k"
# CORRECTED THIS based on your log output: 'chhunlichhean_kun@wing'
TARGET_BAKONG_ACCOUNT_ID = "net_noeurn@trmc"
# ========================


# á‘á·á“áŸ’á“á“áŸá™á‚áá“á¸á¢áŸ’á“á€á”áŸ’ášá¾á”áŸ’ášá¶áŸáŸ‹ (Bot á“áŸáŸ‡á“á¹á„á”á“áŸ’áá”áŸ’ášá¾á‘á·á“áŸ’á“á“áŸá™á€áŸ’á“á»á„ memory á“áŸáŸ‡)
user_accounts = {
    1380299845: {
        "balance": 100.0,
        "transactions": [],
        "orders": [
            {
                "service_name": "Facebook Page Likes + Followers",
                "quantity": 1000,
                "link": "http://facebook.com/test",
                "cost": 5.0,
                "timestamp": "2025-06-15 10:30:00",
                "smm_order_id": 12345
            }
        ]
    }
}

# --- á”áŸŠá¼áá»á„ Menu àº«àº¼á¶á€áŸ‹ (Main ReplyKeyboard) ---
BTN_ORDER = "ğŸ›’ áŸáŸáœá¶á€á˜áŸ’á˜"
BTN_DEPOSIT = "ğŸ’° áŠá¶á€áŸ‹á”áŸ’ášá¶á€áŸ‹"
BTN_BALANCE = "ğŸ’µ á‘á¹á€á”áŸ’ášá¶á€áŸ‹ášá”áŸáŸ‹ááŸ’á‰á»áŸ†"
BTN_HISTORY = "ğŸ“œ á”áŸ’ášáœááŸ’áá·á”á‰áŸ’á‡á¶á‘á·á‰"
BTN_USER_ID = "ğŸ†” á›áŸááŸá˜áŸ’á‚á¶á›áŸ‹ášá”áŸáŸ‹ááŸ’á‰á»áŸ†"
BTN_CONTACT = "ğŸ‘¨â€ğŸ’» á‘á¶á€áŸ‹á‘á„á¢áŸ’á“á€á‚áŸ’ášá”áŸ‹á‚áŸ’ášá„"

# --- á”áŸŠá¼áá»á„ Platforms (ReplyKeyboard, shown after BTN_ORDER) ---
BTN_TIKTOK_PLATFORM = "âš«ï¸ Tik Tok"
BTN_YOUTUBE_PLATFORM = "ğŸ”´ YouTube"
BTN_FACEBOOK_PLATFORM = "ğŸ”µ Facebook"
BTN_TWITTER_PLATFORM = "ğŸŸ£ Twitter"
BTN_TELEGRAM_PLATFORM = "ğŸŸ¢ Telegram"
BTN_INSTAGRAM_PLATFORM = "ğŸŸ¡ Instagram"

# --- Other Action Buttons (ReplyKeyboard, also shown after BTN_ORDER) ---
BTN_HOW_TO_BUY = "ğŸ›ï¸ ášá”áŸ€á”á‘á·á‰ / How To Buy"
BTN_JOIN_CHANNEL = "â¡ï¸ Join Channel"
BTN_ADMIN_CHAT = "ğŸ§‘â€ğŸ’» Admin" # Changed emoji as per provided image

# --- Back Button (ReplyKeyboard) ---
BTN_BACK_TO_MAIN_MENU = "â¬…ï¸ áá™á€áŸ’ášáŸ„á™"
BTN_BACK_TO_PLATFORMS = "â¬…ï¸ áá™á€áŸ’ášáŸ„á™" # Reusing for conceptual clarity, maps to 'check_services_from_text' callback

# --- SMM Panel API Client ---
class SMMClient:
    def __init__(self, api_url, api_key):
        self.api_url = api_url
        self.api_key = api_key
        import httpx
        self.client = httpx.AsyncClient(base_url=self.api_url, timeout=30.0)

    async def _make_request(self, action, params=None):
        payload = {"key": self.api_key, "action": action}
        if params:
            payload.update(params)

        try:
            import httpx
            response = await self.client.post("/", data=payload)
            response.raise_for_status()
            return response.json()
        except httpx.HTTPStatusError as e:
            logger.error(f"HTTP error for SMM API request (action={action}): {e.response.status_code} - {e.response.text}")
            return {"error": f"HTTP Error: {e.response.status_code}"}
        except httpx.RequestError as e:
            logger.error(f"Network error for SMM API request (action={action}): {e}")
            return {"error": f"Network Error: {e}"}
        except Exception as e:
            logger.error(f"Unexpected error for SMM API request (action={action}): {e}")
            return {"error": f"Unexpected Error: {e}"}

    async def add_order(self, smm_service_id, link, quantity):
        logger.info(f"Sending order to SMM panel: service={smm_service_id}, link={link}, quantity={quantity}")
        params = { "service": smm_service_id, "link": link, "quantity": quantity }
        response = await self._make_request("add", params)
        if response and "order" in response:
            logger.info(f"SMM Order successful: Order ID {response['order']}")
            return {"success": True, "order_id": response["order"]}

        error_msg = response.get("error", "Unknown error adding order.")
        logger.error(f"Failed to add order to SMM panel: {error_msg}. Response: {response}")
        return {"success": False, "error": error_msg}

    async def get_balance(self):
        logger.info("Attempting to get balance from SMM panel...")
        response = await self._make_request("balance")
        if response and "balance" in response:
            logger.info(f"SMM balance: {response['balance']} {response.get('currency', 'USD')}")
            return {"success": True, "balance": float(response["balance"]), "currency": response.get("currency", "USD")}

        error_msg = response.get("error", "Unknown error when getting balance.")
        logger.error(f"Failed to get balance from SMM panel: {error_msg}. Response: {response}")
        return {"success": False, "error": error_msg}

smm_client = SMMClient(SMM_API_CONFIG["SMM_API_URL"], SMM_API_CONFIG["SMM_API_KEY"])


# --- á˜á»áá„á¶áš Bot áŸá˜áŸ’ášá¶á”áŸ‹á¢áŸ’á“á€á”áŸ’ášá¾á”áŸ’ášá¶áŸáŸ‹á‘á¼á‘áŸ… ---
async def get_main_menu_keyboard():
    """Returns the main ReplyKeyboardMarkup for the start menu."""
    keyboard = [
        [KeyboardButton(BTN_ORDER), KeyboardButton(BTN_DEPOSIT)],
        [KeyboardButton(BTN_BALANCE), KeyboardButton(BTN_HISTORY)],
        [KeyboardButton(BTN_USER_ID), KeyboardButton(BTN_CONTACT)]
    ]
    return ReplyKeyboardMarkup(keyboard, resize_keyboard=True)

async def get_platform_selection_keyboard():
    """Returns the ReplyKeyboardMarkup for platform selection after 'Order'."""
    platform_buttons = [
        [KeyboardButton(BTN_TIKTOK_PLATFORM), KeyboardButton(BTN_YOUTUBE_PLATFORM), KeyboardButton(BTN_FACEBOOK_PLATFORM)],
        [KeyboardButton(BTN_TWITTER_PLATFORM), KeyboardButton(BTN_TELEGRAM_PLATFORM), KeyboardButton(BTN_INSTAGRAM_PLATFORM)],
        [KeyboardButton(BTN_HOW_TO_BUY)],
        [KeyboardButton(BTN_JOIN_CHANNEL), KeyboardButton(BTN_ADMIN_CHAT)],
        [KeyboardButton(BTN_BACK_TO_MAIN_MENU)] # Back button for platforms
    ]
    return ReplyKeyboardMarkup(platform_buttons, resize_keyboard=True)

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """á•áŸ’á‰á¾áŸá¶ášáŸáŸ’áœá¶á‚á˜á“áŸ à¸à¸£à¹‰à¸­à¸¡à¸à¸±à¸š ReplyKeyboardMarkup áŠáŸ‚á›á‡á¶á”áŸŠá¼áá»á„ Menu àº«àº¼á¶á€áŸ‹"""
    reply_markup = await get_main_menu_keyboard()
    reply_text = 'áŸá¼á˜áŸáŸ’áœá¶á‚á˜á“áŸá˜á€á€á¶á“áŸ‹ SMM Bot! áŸá¼á˜á‡áŸ’ášá¾áŸášá¾áŸá‡á˜áŸ’ášá¾áŸáá¶á„á€áŸ’ášáŸ„á˜áŸ–'
    
    if update.callback_query:
        await update.callback_query.answer()
        # Edit the message to show the start menu again if it was a callback from an old menu
        try:
            await update.callback_query.message.edit_text(
                text=reply_text,
                reply_markup=reply_markup,
                parse_mode='Markdown'
            )
        except BadRequest: # Message can't be edited if it's too old or deleted
            await context.bot.send_message(
                chat_id=update.effective_chat.id,
                text=reply_text,
                reply_markup=reply_markup,
                parse_mode='Markdown'
            )
    else:
        await context.bot.send_message(
            chat_id=update.effective_chat.id,
            text=reply_text,
            reply_markup=reply_markup,
            parse_mode='Markdown'
        )
    
    context.user_data.clear()
    return ConversationHandler.END


async def button_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """à¸ˆà¸±à¸”à¸à¸²à¸£à¹€à¸‰à¸à¸²à¸° CallbackQuery à¸—à¸µà¹ˆà¹€à¸«à¸¥à¸·à¸­à¸­à¸¢à¸¹à¹ˆ (à¹€à¸Šà¹ˆà¸™ á€á¶ášá‡áŸ’ášá¾áŸášá¾áŸáŸáŸáœá¶á€á˜áŸ’á˜, ááŸ’ášá¡á”áŸ‹)"""
    query = update.callback_query
    await query.answer()

    if query.data.startswith('show_services_'):
        platform_name_with_emoji = query.data.replace('show_services_', '')
        # Extract the clean platform name without emoji
        platform_name = platform_name_with_emoji.split(' ')[-1] if ' ' in platform_name_with_emoji else platform_name_with_emoji
        
        services = services_data.get(platform_name, [])
        if services:
            # Create a list of service buttons, adding the back button at the end
            buttons = [[InlineKeyboardButton(f"ğŸ”— **{s['name']}** ({s['price_per_k']}$/1K)", callback_data=f"buy_service_{platform_name}_{s['id']}")] for s in services if "smm_service_id" in s]
            if not buttons:
                    await query.edit_message_text(text=f"á˜á·á“á˜á¶á“áŸáŸáœá¶á€á˜áŸ’á˜áŸá˜áŸ’ášá¶á”áŸ‹ **{platform_name}** á‘áŸáŸ”", parse_mode='Markdown')
                    return
            buttons.append([InlineKeyboardButton(BTN_BACK_TO_PLATFORMS, callback_data='show_platform_menu_from_inline')]) # Back button for inline services
            await query.edit_message_text(text=f"áŸáŸáœá¶á€á˜áŸ’á˜áŸá˜áŸ’ášá¶á”áŸ‹ **{platform_name}**áŸ–", reply_markup=InlineKeyboardMarkup(buttons), parse_mode='Markdown')
        else:
            await query.edit_message_text(text=f"á˜á·á“á˜á¶á“áŸáŸáœá¶á€á˜áŸ’á˜áŸá˜áŸ’ášá¶á”áŸ‹ **{platform_name}** á‘áŸáŸ”", parse_mode='Markdown')
    
    elif query.data == 'show_platform_menu_from_inline':
        # This callback is used to return to the platform selection ReplyKeyboard
        await main_menu_handler(update, context, command=BTN_ORDER) # Simulate clicking BTN_ORDER to show platforms
        # We try to delete the old message that had inline keyboard, it might fail if user already deleted it.
        try:
            await query.message.delete()
        except BadRequest:
            pass # Ignore if message not found

    elif query.data == 'start_menu':
        await start(update, context)


async def main_menu_handler(update: Update, context: ContextTypes.DEFAULT_TYPE, command=None):
    """à¸ˆà¸±à¸”à¸à¸²à¸£à¸„à¸³à¸ªà¸±à¹ˆà¸‡à¸ˆà¸²à¸ ReplyKeyboard (á”áŸŠá¼áá»á„ Menu àº«àº¼á¶á€áŸ‹) á¬á”áŸŠá¼áá»á„ Platform"""
    # Determine the command: either from the text message or explicitly passed
    effective_command = command if command else update.message.text
    user_id = update.effective_user.id
    user_first_name = update.effective_user.first_name or "á¢áŸ’á“á€á”áŸ’ášá¾á”áŸ’ášá¶áŸáŸ‹" # Get user's first name, fallback to "User"
    
    # Determine the target message to reply/edit. For ReplyKeyboard interactions, it's usually a new reply.
    # In some cases, we might delete the previous message.
    target_message = update.message # For direct text messages from ReplyKeyboard

    if effective_command == BTN_ORDER:
        # Dynamic greeting using user's first name
        message_text = f"áŸá½áŸáŸ’áŠá¸! {user_first_name} ğŸ‘‹\náŸá¼á˜á‡áŸ’ášá¾áŸášá¾áŸ platform áŠáŸ‚á›á¢áŸ’á“á€á…á„áŸ‹á‘á·á‰"
        reply_markup_platforms = await get_platform_selection_keyboard()
        
        # Always send a new message when displaying a new ReplyKeyboardMarkup
        await context.bot.send_message(
            chat_id=update.effective_chat.id,
            text=message_text,
            reply_markup=reply_markup_platforms,
            parse_mode='Markdown'
        )

    # Handle clicks on the new platform buttons (now they are MessageHandlers)
    elif effective_command in [BTN_TIKTOK_PLATFORM, BTN_YOUTUBE_PLATFORM, BTN_FACEBOOK_PLATFORM, 
                               BTN_TWITTER_PLATFORM, BTN_TELEGRAM_PLATFORM, BTN_INSTAGRAM_PLATFORM]:
        
        # When a platform button from the ReplyKeyboard is clicked, send a message
        # with an Inline Keyboard button that then triggers the service display.
        platform_name = effective_command # Keep emoji for button text, but strip for data retrieval later
        
        # We need to send an inline keyboard to choose services.
        # The inline keyboard will have a single button that, when clicked,
        # will show the actual list of services.
        keyboard = [
            [InlineKeyboardButton(f"á˜á¾á›áŸáŸáœá¶á€á˜áŸ’á˜áŸá˜áŸ’ášá¶á”áŸ‹ {platform_name}", callback_data=f"show_services_{platform_name}")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)

        # Send this inline keyboard, ideally by editing the previous message if possible,
        # or sending a new one if not. For ReplyKeyboards, it's usually a new message.
        await update.message.reply_text(
            f"á¢áŸ’á“á€á”á¶á“á‡áŸ’ášá¾áŸášá¾áŸ **{platform_name}** áŸ”\n\náŸá¼á˜á…á»á…á”áŸŠá¼áá»á„áá¶á„á€áŸ’ášáŸ„á˜áŠá¾á˜áŸ’á”á¸á˜á¾á›áŸáŸáœá¶á€á˜áŸ’á˜:",
            reply_markup=reply_markup,
            parse_mode='Markdown'
        )


    elif effective_command == BTN_BALANCE:
        balance = user_accounts.get(user_id, {}).get("balance", 0)
        await target_message.reply_text(text=f"ğŸ’° á‘á¹á€á”áŸ’ášá¶á€áŸ‹á€áŸ’á“á»á„ AccountáŸ– **{balance:.2f}$ USD**", parse_mode='Markdown')

    elif effective_command == BTN_CONTACT:
        await target_message.reply_text(text="ğŸ‘¨â€ğŸ’» áŸá¼á˜á‘áŸ†á“á¶á€áŸ‹á‘áŸ†á“á„á¢áŸ’á“á€á‚áŸ’ášá”áŸ‹á‚áŸ’ášá„áŸ– **@punetDigital168**", parse_mode='Markdown')

    elif effective_command == BTN_USER_ID:
        await target_message.reply_text(text=f"ğŸ”‘ User ID: `{user_id}`", parse_mode='Markdown')
    
    elif effective_command == BTN_DEPOSIT:
        await start_deposit(update, context) # Call the deposit handler
    
    elif effective_command == BTN_HISTORY:
        await show_order_history(update, context)
        
    elif effective_command == BTN_HOW_TO_BUY:
        await target_message.reply_text(text="â„¹ï¸ **ášá”áŸ€á”á‘á·á‰áŸáŸáœá¶á€á˜áŸ’á˜áŸ–**\n\n1. á…á»á…á›á¾ Platform áŠáŸ‚á›á¢áŸ’á“á€á…á„áŸ‹á‘á·á‰áŸ”\n2. á‡áŸ’ášá¾áŸášá¾áŸáŸáŸáœá¶á€á˜áŸ’á˜áŠáŸ‚á›á¢áŸ’á“á€á…á„áŸ‹á”á¶á“áŸ”\n3. á”á‰áŸ’á…á¼á› Link á“á·á„á…áŸ†á“á½á“áŠáŸ‚á›á¢áŸ’á“á€á…á„áŸ‹á‘á·á‰áŸ”\n4. á”á‰áŸ’á‡á¶á€áŸ‹á€á¶ášá”á‰áŸ’á‡á¶á‘á·á‰ á“á·á„ášá„áŸ‹á…á¶áŸ†á€á¶ášáŠáŸ†áá¾ášá€á¶ášáŸ”", parse_mode='Markdown')

    elif effective_command == BTN_JOIN_CHANNEL:
        await target_message.reply_text(text="â¡ï¸ **áŸá¼á˜á…á¼á›ášá½á˜ Channel ášá”áŸáŸ‹á™á¾á„ááŸ’á‰á»áŸ†áŠá¾á˜áŸ’á”á¸á‘á‘á½á›á”á¶á“á–áŸááŸŒá˜á¶á“ááŸ’á˜á¸áŸ—:**\n\n[Link á‘áŸ…á€á¶á“áŸ‹ Channel ášá”áŸáŸ‹á¢áŸ’á“á€](https://t.me/your_channel_link)", parse_mode='Markdown') # Replace with your actual channel link

    elif effective_command == BTN_ADMIN_CHAT:
        await target_message.reply_text(text="ğŸ§‘â€ğŸ’» **áŸá˜áŸ’ášá¶á”áŸ‹á‘áŸ†á“á¶á€áŸ‹á‘áŸ†á“á„ Admin:** @PHENNG", parse_mode='Markdown') # As seen in the image
    
    elif effective_command == BTN_BACK_TO_MAIN_MENU:
        await start(update, context) # Go back to the main start menu keyboard


# --- á˜á»áá„á¶ášáŠá¶á€áŸ‹á”áŸ’ášá¶á€áŸ‹ááŸ’á˜á¸ ---
async def generate_khqr_code(amount: float):
    """á áŸ…á‘áŸ… API áŠá¾á˜áŸ’á”á¸á”á„áŸ’á€á¾á QR Code Bakong KHQR"""
    api_url = f"https://api.kunchhunlichhean.org/khqr/create?amount={amount}&bakongid=net_noeurn@trmc&merchantname=CHHEANSMM"
    try:
        # Make the GET request to the API
        response = requests.get(api_url)
        response.raise_for_status() # Will raise HTTPError for bad responses (4xx or 5xx)
        response_data = response.json()

        qr_code_url = response_data.get('qr')
        md5 = response_data.get('md5')

        if qr_code_url and md5:
            return {
                'qr_url': qr_code_url,
                'md5': md5,
                'amount': amount
            }, None
        else:
            return None, f"Failed to generate QR code: Missing QR code URL or MD5 in response. Response: {response_data}"
    except requests.exceptions.RequestException as e:
        logger.error(f"Error calling KHQR API: {e}")
        return None, f"Failed to connect to QR generation service: {e}"
    except Exception as e:
        logger.error(f"Unexpected error in generate_khqr_code: {e}")
        return None, f"An unexpected error occurred during QR generation: {e}"

async def check_bakong_md5_api(md5: str) -> bool:
    """á–á·á“á·ááŸ’á™áŸáŸ’áá¶á“á—á¶á–á”áŸ’ášáá·á”ááŸ’áá·á€á¶ášáŠáŸ„á™á”áŸ’ášá¾ MD5 API ášá”áŸáŸ‹ Bakong"""
    url = 'https://api-bakong.nbc.gov.kh/v1/check_transaction_by_md5'
    headers = {
        'Authorization': f'Bearer {BAKONG_API_TOKEN}',
        'Content-Type': 'application/json',
    }
    data = {
        'md5': md5
    }

    try:
        response = requests.post(url, headers=headers, json=data)
        response.raise_for_status()
        response_data = response.json()

        logger.info(f"Bakong API response for MD5 {md5}: {response_data}") # Added for debugging

        # Check if responseCode is 0 (success) and toAccountId matches
        if response_data.get('responseCode') == 0 and response_data.get('data', {}).get('toAccountId') == TARGET_BAKONG_ACCOUNT_ID:
            logger.info(f"MD5 {md5} check successful. Transaction confirmed to {TARGET_BAKONG_ACCOUNT_ID}.")
            return True
        else:
            logger.info(f"MD5 {md5} check returned non-success or mismatched account. Expected '{TARGET_BAKONG_ACCOUNT_ID}', Got '{response_data.get('data', {}).get('toAccountId') if response_data.get('data') else 'N/A'}'. Full response: {response_data}")
            return False
    except requests.exceptions.RequestException as e:
        logger.error(f"Error checking Bakong MD5 API for {md5}: {e}")
        return False
    except Exception as e:
        logger.error(f"Unexpected error in check_bakong_md5_api for {md5}: {e}")
        return False

async def start_deposit(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """á…á¶á”áŸ‹á•áŸ’áá¾á˜áŠáŸ†áá¾ášá€á¶ášáŠá¶á€áŸ‹á”áŸ’ášá¶á€áŸ‹"""
    await update.message.reply_text(
        text="ğŸ’µ **áŸá¼á˜á”á‰áŸ’á…á¼á›á…áŸ†á“á½á“á‘á¹á€á”áŸ’ášá¶á€áŸ‹áŠáŸ‚á›á¢áŸ’á“á€á…á„áŸ‹áŠá¶á€áŸ‹ (USD):**\n\ná§á‘á¶á ášááŸ: `10` á¬ `25.5`\n\náœá¶á™ /cancel áŠá¾á˜áŸ’á”á¸á”áŸ„áŸ‡á”á„áŸ‹áŸ”",
        parse_mode='Markdown'
    )
    return DEPOSIT_AMOUNT

async def receive_deposit_amount(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """á‘á‘á½á›á…áŸ†á“á½á“á‘á¹á€á”áŸ’ášá¶á€áŸ‹ ášá½á…á”á„áŸ’á€á¾á QR á“á·á„á…á¶á”áŸ‹á•áŸ’áá¾á˜á–á·á“á·ááŸ’á™ MD5"""
    try:
        amount = float(update.message.text)
        if amount <= 0:
            raise ValueError("Amount must be positive.")
    except (ValueError, TypeError):
        await update.message.reply_text(
            "âŒ á…áŸ†á“á½á“á‘á¹á€á”áŸ’ášá¶á€áŸ‹á˜á·á“ááŸ’ášá¹á˜ááŸ’ášá¼áœá‘áŸáŸ” áŸá¼á˜á–áŸ’á™á¶á™á¶á˜á˜áŸ’áá„á‘áŸ€á (á§. `10`) á¬áœá¶á™ /cancel áŠá¾á˜áŸ’á”á¸á”áŸ„áŸ‡á”á„áŸ‹áŸ”",
            parse_mode='Markdown'
        )
        return DEPOSIT_AMOUNT

    user = update.effective_user
    transaction_code = str(uuid.uuid4().hex)[:8].upper()
    
    # á”á„áŸ’á á¶á‰áŸá¶ášášá„áŸ‹á…á¶áŸ†
    message_to_delete = await update.message.reply_text("ğŸ”„ á€áŸ†á–á»á„á”á„áŸ’á€á¾á QR Code... áŸá¼á˜ášá„áŸ‹á…á¶áŸ†áŸ”")

    qr_info, error = await generate_khqr_code(amount)

    if error:
        try:
            await message_to_delete.edit_text(f"âŒ á˜á·á“á¢á¶á…á”á„áŸ’á€á¾á QR Code á”á¶á“á‘áŸáŸ– `{error}`\náŸá¼á˜á–áŸ’á™á¶á™á¶á˜á˜áŸ’áá„á‘áŸ€áá“áŸ…á–áŸá›á€áŸ’ášáŸ„á™áŸ”", parse_mode='Markdown')
        except BadRequest: # If message was already deleted or too old
            await update.message.reply_text(f"âŒ á˜á·á“á¢á¶á…á”á„áŸ’á€á¾á QR Code á”á¶á“á‘áŸáŸ– `{error}`\náŸá¼á˜á–áŸ’á™á¶á˜á˜áŸ’áá„á‘áŸ€áá“áŸ…á–áŸá›á€áŸ’ášáŸ„á™áŸ”", parse_mode='Markdown')
        return ConversationHandler.END

    qr_code_url = qr_info['qr_url']
    md5 = qr_info['md5']
    
    # ášá€áŸ’áŸá¶á‘á»á€á–áŸááŸŒá˜á¶á“áŠá¶á€áŸ‹á”áŸ’ášá¶á€áŸ‹á”ááŸ’ááŸ„áŸ‡á¢á¶áŸá“áŸ’á“
    context.bot_data['pending_deposits'][transaction_code] = {
        'user_id': user.id,
        'username': user.username,
        'full_name': user.full_name,
        'amount': amount,
        'md5': md5,
        'timestamp': datetime.datetime.now().isoformat(),
        'chat_id': update.effective_chat.id, # áŠá¾á˜áŸ’á”á¸á¢á¶á…á•áŸ’á‰á¾áŸá¶ášááŸ’ášá¡á”áŸ‹á‘áŸ… user áœá·á‰
        'admin_msg_id': None # á“á¹á„ááŸ’ášá¼áœá”á¶á“á”áŸ†á–áŸá‰á”á“áŸ’á‘á¶á”áŸ‹á–á¸á•áŸ’á‰á¾áŸá¶ášá‘áŸ… Admin
    }

    # User message with QR Code
    caption_text = (
        f"**ğŸ’° á–áŸááŸŒá˜á¶á“áŸá˜áŸ’ášá¶á”áŸ‹á€á¶ášáŠá¶á€áŸ‹á”áŸ’ášá¶á€áŸ‹** ğŸ’°\n\n"
        f"**á…áŸ†á“á½á“á‘á¹á€á”áŸ’ášá¶á€áŸ‹áŠáŸ‚á›ááŸ’ášá¼áœáŠá¶á€áŸ‹:** `${amount:.2f} USD`\n"
        f"áŸá¼á˜áŸáŸ’á€áŸá“ QR Code áá¶á„á€áŸ’ášáŸ„á˜áŠá¾á˜áŸ’á”á¸á”á„áŸ‹á”áŸ’ášá¶á€áŸ‹áŸ”\n"
        f"á™á¾á„á€áŸ†á–á»á„ášá„áŸ‹á…á¶áŸ†á€á¶ášá‘á¼á‘á¶ááŸ‹ášá”áŸáŸ‹á¢áŸ’á“á€áŸ” á”áŸ’ášá–áŸá“áŸ’á’á“á¹á„á”á‰áŸ’á…á¼á›á”áŸ’ášá¶á€áŸ‹áŠáŸ„á™áŸáŸ’áœáŸá™á”áŸ’ášáœááŸ’áá·áŸ”"
    )

    try:
        # á‘á¶á‰á™á€ášá¼á”á—á¶á– QR Code á–á¸ URL
        qr_image_response = requests.get(qr_code_url)
        qr_image_response.raise_for_status()
        qr_image_bytes = io.BytesIO(qr_image_response.content)

        await context.bot.send_photo(
            chat_id=update.effective_chat.id,
            photo=qr_image_bytes,
            caption=caption_text,
            parse_mode='Markdown'
        )
        try:
            await message_to_delete.delete() # á›á»á”áŸá¶ášášá„áŸ‹á…á¶áŸ†
        except BadRequest: # Message might already be gone
            pass
    except requests.exceptions.RequestException as e:
        logger.error(f"Error fetching QR image from {qr_code_url}: {e}")
        await update.message.reply_text(
            f"âŒ á˜á·á“á¢á¶á…á”á„áŸ’á á¶á‰ QR Code á”á¶á“á‘áŸáŸ” á”á‰áŸ’á á¶áŸ– `{e}`\n"
            f"áŸá¼á˜á”á„áŸ‹á”áŸ’ášá¶á€áŸ‹áŠáŸ„á™á•áŸ’á‘á¶á›áŸ‹á‘áŸ…á‚áá“á¸ Bakong ID: `{TARGET_BAKONG_ACCOUNT_ID}` á…áŸ†á“á½á“ `${amount:.2f} USD` á á¾á™á”áŸ’ášá¾ `{md5}` á‡á¶ ReferenceáŸ”\n"
            f"á€á¼áŠá”áŸ’ášáá·á”ááŸ’áá·á€á¶ášášá”áŸáŸ‹á¢áŸ’á“á€á‚áº `{transaction_code}`áŸ”",
            parse_mode='Markdown' 
        )
    except Exception as e:
        logger.error(f"Unexpected error sending QR photo: {e}")
        await update.message.reply_text(
            f"âŒ á˜á¶á“á”á‰áŸ’á á¶á€áŸ’á“á»á„á€á¶ášá”á„áŸ’á á¶á‰ QR CodeáŸ”\n"
            f"áŸá¼á˜á”á„áŸ‹á”áŸ’ášá¶á€áŸ‹áŠáŸ„á™á•áŸ’á‘á¶á›áŸ‹á‘áŸ…á‚ááá¸ Bakong ID: `{TARGET_BAKONG_ACCOUNT_ID}` á…áŸ†á“á½á“ `${amount:.2f} USD` á á¾á™á”áŸ’ášá¾ `{md5}` á‡á¶ ReferenceáŸ”\n"
            f"á€á¼áŠá”áŸ’ášáá·á”ááŸ’áá·á€á¶ášášá”áŸáŸ‹á¢áŸ’á“á€á‚áº `{transaction_code}`áŸ”",
            parse_mode='Markdown' 
        )
    
    # Admin message with confirmation buttons - Using HTML parse_mode for robustness
    admin_message_text = (
        f"ğŸ”” <b>áŸáŸ†áá¾áŠá¶á€áŸ‹á”áŸ’ášá¶á€áŸ‹ááŸ’á˜á¸ (Auto-Check)</b> ğŸ””\n\n"
        f"<b>á–á¸:</b> {user.full_name} (@{user.username if user.username else 'N/A'}, ID: <code>{user.id}</code>)\n"
        f"<b>á…áŸ†á“á½á“:</b> <code>${amount:.2f} USD</code>\n"
        f"<b>Transaction Code:</b> <code>{transaction_code}</code>\n"
        f"<b>MD5:</b> <code>{md5}</code>\n\n"
        f"á”áŸ’ášá–áŸá“áŸ’á’á€áŸ†á–á»á„á–á·á“á·ááŸ’á™áŠáŸ„á™áŸáŸ’áœáŸá™á”áŸ’ášáœááŸ’áá·áŸ” á¢áŸ’á“á€á€áŸá¢á¶á…á…á»á…á”áŸŠá¼áá»á„áá¶á„á€áŸ’ášáŸ„á˜áŠá¾á˜áŸ’á”á¸á¢á“á»á˜áŸá/á”áŠá·áŸáŸá’áŠáŸ„á™áŠáŸƒáŸ”"
    )
    keyboard = [
        [
            InlineKeyboardButton("ğŸ‘ á™á›áŸ‹á–áŸ’ášá˜ (áŠáŸ„á™áŠáŸƒ)", callback_data=f'deposit_approve_{transaction_code}'),
            InlineKeyboardButton("ğŸ‘ á”áŠá·áŸáŸá’ (áŠáŸ„á™áŠáŸƒ)", callback_data=f'deposit_reject_{transaction_code}')
        ]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)

    try:
        admin_msg = await context.bot.send_message(
            chat_id=DEPOSIT_CONFIRMATION_CHAT_ID,
            text=admin_message_text,
            reply_markup=reply_markup,
            parse_mode='HTML' # <--- Changed to HTML for admin messages
        )
        context.bot_data['pending_deposits'][transaction_code]['admin_msg_id'] = admin_msg.message_id
    except TelegramError as e: # Catch specific Telegram errors
        logger.error(f"Could not send deposit confirmation to admin chat {DEPOSIT_CONFIRMATION_CHAT_ID}. Error: {e}")
        if ADMIN_USER_IDS:
            try:
                # Send a more detailed error message to an admin if possible
                await context.bot.send_message(
                    chat_id=ADMIN_USER_IDS[0],
                    text=f"âš ï¸ <b>CRITICAL ERROR:</b> Failed to send deposit request <code>{transaction_code}</code> to admin chat <code>{DEPOSIT_CONFIRMATION_CHAT_ID}</code>. Error: <code>{e}</code>\n"
                         f"Please ensure the <code>DEPOSIT_CONFIRMATION_CHAT_ID</code> is correct and the bot is an admin in that group/chat.",
                    parse_mode='HTML'
                )
            except Exception as e_admin:
                logger.error(f"FATAL: Could not even send error message to main admin {ADMIN_USER_IDS[0]}. Error: {e_admin}")

    # á”á“áŸ’ááŸ‚á˜ Job á‘áŸ… JobQueue áŠá¾á˜áŸ’á”á¸á–á·á“á·ááŸ’á™ MD5 
    context.job_queue.run_repeating(
        check_payment_job,
        interval=10, # á–á·á“á·ááŸ’á™ášáŸ€á„ášá¶á›áŸ‹ 10 áœá·á“á¶á‘á¸
        first=10,    # á…á¶á”áŸ‹á•áŸ’áá¾á˜á–á·á“á·ááŸ’á™á”á“áŸ’á‘á¶á”áŸ‹á–á¸ 10 áœá·á“á¶á‘á¸
        data={'transaction_code': transaction_code},
        name=f"md5_check_{transaction_code}"
    )

    # á€áŸ†áááŸ‹á–áŸá›áŸá˜áŸ’ášá¶á”áŸ‹á›á»á” Job á…áŸá‰ á”áŸ’ášáŸá·á“á”á¾á›á¾áŸá–áŸá› (e.g., 5 minutes timeout)
    context.job_queue.run_once(
        remove_deposit_job_if_timeout,
        when=datetime.timedelta(minutes=5), # Change to 5 minutes, 3 was too short
        data={'transaction_code': transaction_code},
        name=f"timeout_job_{transaction_code}"
    )

    return ConversationHandler.END


async def check_payment_job(context: ContextTypes.DEFAULT_TYPE):
    """Job function áŠá¾á˜áŸ’á”á¸á–á·á“á·ááŸ’á™ MD5 á‡á¶á”áŸ’ášá…á¶áŸ†"""
    transaction_code = context.job.data['transaction_code']
    
    pending_deposit = context.bot_data.get('pending_deposits', {}).get(transaction_code)

    if not pending_deposit:
        logger.info(f"Job for {transaction_code} found no pending deposit. Removing job.")
        context.job.schedule_removal()
        return

    md5 = pending_deposit['md5']
    user_id = pending_deposit['user_id']
    amount = pending_deposit['amount']
    chat_id = pending_deposit['chat_id']
    admin_msg_id = pending_deposit['admin_msg_id']
    full_name = pending_deposit['full_name']

    payment_confirmed = await check_bakong_md5_api(md5)

    if payment_confirmed:
        if user_id not in user_accounts:
            user_accounts[user_id] = {"balance": 0.0, "transactions": [], "orders": []}
        user_accounts[user_id]["balance"] += amount
        user_accounts[user_id]["transactions"].append(f"+{amount:.2f}$ (Auto Deposit {transaction_code})")
        new_balance = user_accounts[user_id]['balance']

        try:
            await context.bot.send_message(
                chat_id=chat_id,
                text=f"âœ… **á€á¶ášáŠá¶á€áŸ‹á”áŸ’ášá¶á€áŸ‹áŠáŸ„á™áŸáŸ’áœáŸá™á”áŸ’ášáœááŸ’áá·á”á¶á“á‡áŸ„á‚á‡áŸá™!**\n\n"
                     f"á‘á¹á€á”áŸ’ášá¶á€áŸ‹á…áŸ†á“á½á“ **${amount:.2f}** ááŸ’ášá¼áœá”á¶á“á”á‰áŸ’á…á¼á›á‘áŸ…á€áŸ’á“á»á„á‚áá“á¸ášá”áŸáŸ‹á¢áŸ’á“á€áŸ”\n"
                     f"á‘á¹á€á”áŸ’ášá¶á€áŸ‹á“áŸ…áŸá›áŸ‹: **${new_balance:.2f}**",
                parse_mode='Markdown'
            )
        except TelegramError as e:
            logger.warning(f"Failed to notify user {user_id} about auto-approved deposit {transaction_code}. Error: {e}")

        # Update Admin message
        try:
            final_admin_text = (
                f"âœ… <b>á”á¶á“á™á›áŸ‹á–áŸ’ášá˜áŠáŸ„á™áŸáŸ’áœáŸá™á”áŸ’ášáœááŸ’áá·</b>\n\n"
                f"<b>á¢áŸ’á“á€á”áŸ’ášá¾á”áŸ’ášá¶áŸáŸ‹:</b> {full_name} (ID: <code>{user_id}</code>)\n"
                f"<b>á…áŸ†á“á½á“:</b> <code>${amount:.2f} USD</code>\n"
                f"<b>Transaction Code:</b> <code>{transaction_code}</code>\n\n"
                f"á‘á¹á€á”áŸ’ášá¶á€áŸ‹ááŸ’ášá¼áœá”á¶á“á”á‰áŸ’á…á¼á›á‘áŸ…á€áŸ’á“á»á„á‚áá“á¸á¢áŸ’á“á€á”áŸ’ášá¾á”áŸ’ášá¶áŸáŸ‹ášá½á…ášá¶á›áŸ‹á á¾á™áŸ”"
            )
            if admin_msg_id:
                await context.bot.edit_message_text(
                    chat_id=DEPOSIT_CONFIRMATION_CHAT_ID,
                    message_id=admin_msg_id,
                    text=final_admin_text,
                    parse_mode='HTML', # <--- Changed to HTML
                    reply_markup=None # á›á»á”á”áŸŠá¼áá»á„á…áŸá‰
                )
            else:
                await context.bot.send_message(
                    chat_id=DEPOSIT_CONFIRMATION_CHAT_ID,
                    text=final_admin_text,
                    parse_mode='HTML' # <--- Changed to HTML
                )
        except TelegramError as e:
            logger.error(f"Failed to update/send admin message for auto-approved deposit {transaction_code}: {e}")

        # Remove the deposit from pending list and scheduled jobs
        if transaction_code in context.bot_data['pending_deposits']:
            del context.bot_data['pending_deposits'][transaction_code]
        for job in context.job_queue.get_jobs_by_name(f"timeout_job_{transaction_code}"):
            job.schedule_removal() # á›á»á” timeout job á•á„
        context.job.schedule_removal() # á›á»á” job á”á…áŸ’á…á»á”áŸ’á”á“áŸ’á“á…áŸá‰

    else:
        logger.info(f"Payment for {transaction_code} still pending.")

async def remove_deposit_job_if_timeout(context: ContextTypes.DEFAULT_TYPE):
    """Job function áŠá¾á˜áŸ’á”á¸áŠá€ pending deposit á…áŸá‰ á”áŸ’ášáŸá·á“á”á¾á¢áŸáŸ‹á–áŸá›"""
    transaction_code = context.job.data['transaction_code']
    
    pending_deposit = context.bot_data.get('pending_deposits', {}).get(transaction_code)

    if pending_deposit:
        user_id = pending_deposit['user_id']
        amount = pending_deposit['amount']
        chat_id = pending_deposit['chat_id']
        admin_msg_id = pending_deposit['admin_msg_id']
        full_name = pending_deposit['full_name']

        try:
            await context.bot.send_message(
                chat_id=chat_id,
                text=f"âŒ **á€á¶ášáŠá¶á€áŸ‹á”áŸ’ášá¶á€áŸ‹á”á¶á“á¢áŸáŸ‹á–áŸá›á á¾á™!**\n\n"
                     f"áŸáŸ†áá¾áŠá¶á€áŸ‹á”áŸ’ášá¶á€áŸ‹á…áŸ†á“á½á“ **${amount:.2f}** (Code: `{transaction_code}`) ášá”áŸáŸ‹á¢áŸ’á“á€ááŸ’ášá¼áœá”á¶á“á”áŠá·áŸáŸá’áŠáŸ„á™áŸá¶ášá¢áŸáŸ‹á–áŸá›áŸ”\n\n"
                     f"áŸá¼á˜á‘á¶á€áŸ‹á‘á„á¢áŸ’á“á€á‚áŸ’ášá”áŸ‹á‚áŸ’ášá„áŸá˜áŸ’ášá¶á”áŸ‹á–áŸááŸŒá˜á¶á“á”á“áŸ’ááŸ‚á˜ á¬á…á¶á”áŸ‹á•áŸ’áá¾á˜á€á¶ášáŠá¶á€áŸ‹á”áŸ’ášá¶á€áŸ‹ááŸ’á˜á¸áŸ”",
                parse_mode='Markdown'
            )
        except TelegramError as e:
            logger.warning(f"Failed to notify user {user_id} about timed-out deposit {transaction_code}. Error: {e}")

        # Update Admin message
        try:
            final_admin_text = (
                f"âŒ <b>á”á¶á“á”áŠá·áŸáŸá’áŠáŸ„á™áŸáŸ’áœáŸá™á”áŸ’ášáœááŸ’áá· (á¢áŸáŸ‹á–áŸá›)</b>\n\n"
                f"<b>á¢áŸ’á“á€á”áŸ’ášá¾á”áŸ’ášá¶áŸáŸ‹:</b> {full_name} (ID: <code>{user_id}</code>)\n"
                f"<b>á…áŸ†á“á½á“:</b> <code>${amount:.2f} USD</code>\n"
                f"<b>Transaction Code:</b> <code>{transaction_code}</code>\n\n"
                f"áŸáŸ†áá¾á“áŸáŸ‡ááŸ’ášá¼áœá”á¶á“á›á»á”á…áŸ„á›áŠáŸ„á™áŸá¶ášá¢áŸáŸ‹á–áŸá›áŸ”"
            )
            if admin_msg_id:
                await context.bot.edit_message_text(
                    chat_id=DEPOSIT_CONFIRMATION_CHAT_ID,
                    message_id=admin_msg_id,
                    text=final_admin_text,
                    parse_mode='HTML', # <--- Changed to HTML
                    reply_markup=None # á›á»á”á”áŸŠá¼áá»á„á…áŸá‰
                )
            else:
                await context.bot.send_message(
                    chat_id=DEPOSIT_CONFIRMATION_CHAT_ID,
                    text=final_admin_text,
                    parse_mode='HTML' # <--- Changed to HTML
                )
        except TelegramError as e:
            logger.error(f"Failed to update/send admin message for timed-out deposit {transaction_code}: {e}")

        # Remove the repeating job too
        for job in context.job_queue.get_jobs_by_name(f"md5_check_{transaction_code}"):
            job.schedule_removal()

        del context.bot_data['pending_deposits'][transaction_code]
    else:
        logger.info(f"Timeout job for {transaction_code} found no pending deposit. Likely handled manually.")

async def handle_deposit_confirmation(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """á˜á»áá„á¶ášáŸá˜áŸ’ášá¶á”áŸ‹ Admin á€áŸ’á“á»á„á€á¶ášá¢á“á»á˜áŸá/á”áŠá·áŸáŸá’á€á¶ášáŠá¶á€áŸ‹á”áŸ’ášá¶á€áŸ‹áŠáŸ„á™áŠáŸƒ"""
    query = update.callback_query
    await query.answer()
    admin_user = query.from_user

    if admin_user.id not in ADMIN_USER_IDS:
        await query.answer("â›”ï¸ á¢áŸ’á“á€á˜á·á“á˜áŸ‚á“á‡á¶ Admin á‘áŸáŸ”", show_alert=True)
        return

    action, code = query.data.split('_', 2)[1:]

    pending_deposits = context.bot_data.get('pending_deposits', {})
    deposit_info = pending_deposits.get(code)

    if not deposit_info:
        try:
            await query.edit_message_text(
                text=f"âš ï¸ <b>á”áŸ’ášáá·á”ááŸ’áá·á€á¶ášá”á¶á“áŠáŸ†áá¾ášá€á¶ášášá½á…á á¾á™</b>\n\n"
                     f"áŸáŸ†áá¾áŸá˜áŸ’ášá¶á”áŸ‹á€á¼áŠ <code>{code}</code> á“áŸáŸ‡ááŸ’ášá¼áœá”á¶á“á™á›áŸ‹á–áŸ’ášá˜ á¬á”áŠá·áŸáŸá’ášá½á…á á¾á™áŸ”",
                parse_mode='HTML' # <--- Changed to HTML
            )
        except BadRequest: # Message might be too old or deleted
            await context.bot.send_message(
                chat_id=update.effective_chat.id,
                text=f"âš ï¸ <b>á”áŸ’ášáá·á”ááŸ’áá·á€á¶ášá”á¶á“áŠáŸ†áá¾ášá€á¶ášášá½á…á á¾á™</b>\n\n"
                     f"áŸáŸ†áá¾áŸá˜áŸ’ášá¶á”áŸ‹á€á¼áŠ <code>{code}</code> á“áŸáŸ‡ááŸ’ášá¼áœá”á¶á“á™á›áŸ‹á–áŸ’ášá˜ á¬á”áŠá·áŸáŸá’ášá½á…á á¾á™áŸ”",
                parse_mode='HTML'
            )
        return

    target_user_id = deposit_info['user_id']
    amount = deposit_info['amount']
    full_name = deposit_info['full_name']
    chat_id = deposit_info['chat_id'] # Chat ID ášá”áŸáŸ‹ user áŠá¾á˜
    md5_hash = deposit_info['md5']

    if action == 'approve':
        if target_user_id not in user_accounts:
            user_accounts[target_user_id] = {"balance": 0.0, "transactions": [], "orders": []}
        user_accounts[target_user_id]["balance"] += amount
        user_accounts[target_user_id]["transactions"].append(f"+{amount:.2f}$ (Admin Deposit {code})")
        new_balance = user_accounts[target_user_id]['balance']

        try:
            await context.bot.send_message(
                chat_id=chat_id,
                text=f"âœ… **á€á¶ášáŠá¶á€áŸ‹á”áŸ’ášá¶á€áŸ‹á”á¶á“á‡áŸ„á‚á‡áŸá™!**\n\n"
                     f"á‘á¹á€á”áŸ’ášá¶á€áŸ‹á…áŸ†á“á½á“ **${amount:.2f}** ááŸ’ášá¼áœá”á¶á“á”á‰áŸ’á…á¼á›á‘áŸ…á€áŸ’á“á»á„á‚áá“á¸ášá”áŸáŸ‹á¢áŸ’á“á€áŠáŸ„á™á¢áŸ’á“á€á‚áŸ’ášá”áŸ‹á‚áŸ’ášá„áŸ”\n"
                     f"á‘á¹á€á”áŸ’ášá¶á€áŸ‹á“áŸ…áŸá›áŸ‹: **${new_balance:.2f}**",
                parse_mode='Markdown'
            )
        except TelegramError as e:
            logger.warning(f"Failed to notify user {target_user_id} about manual deposit {code}. Error: {e}")
            await query.answer(f"User {target_user_id} might have blocked the bot. Could not notify.", show_alert=True)

        final_admin_text = (
            f"âœ… <b>á”á¶á“á™á›áŸ‹á–áŸ’ášá˜ (áŠáŸ„á™ {admin_user.full_name})</b>\n\n"
            f"<b>á¢áŸ’á“á€á”áŸ’ášá¾á”áŸ’ášá¶áŸáŸ‹:</b> {full_name} (ID: <code>{target_user_id}</code>)\n"
            f"<b>á…áŸ†á“á½á“:</b> <code>${amount:.2f} USD</code>\n"
            f"<b>Transaction Code:</b> <code>{code}</code>\n"
            f"<b>MD5:</b> <code>{md5_hash}</code>\n\n"
            f"á‘á¹á€á”áŸ’ášá¶á€áŸ‹ááŸ’ášá¼áœá”á¶á“á”á‰áŸ’á…á¼á›á‘áŸ…á€áŸ’á“á»á„á‚áá“á¸á¢áŸ’á“á€á”áŸ’ášá¾á”áŸ’ášá¶áŸáŸ‹ášá½á…ášá¶á›áŸ‹á á¾á™áŸ”"
        )
        try:
            await query.edit_message_text(text=final_admin_text, parse_mode='HTML', reply_markup=None) # <--- Changed to HTML
        except BadRequest:
            await context.bot.send_message(
                chat_id=update.effective_chat.id,
                text=final_admin_text, parse_mode='HTML', reply_markup=None
            )

    elif action == 'reject':
        try:
            await context.bot.send_message(
                chat_id=chat_id,
                text=f"âŒ **á€á¶ášáŠá¶á€áŸ‹á”áŸ’ášá¶á€áŸ‹ááŸ’ášá¼áœá”á¶á“á”áŠá·áŸáŸá’**\n\n"
                     f"áŸáŸ†áá¾áŠá¶á€áŸ‹á”áŸ’ášá¶á€áŸ‹á…áŸ†á“á½á“ **${amount:.2f}** (Code: `{code}`) ášá”áŸáŸ‹á¢áŸ’á“á€ááŸ’ášá¼áœá”á¶á“á”áŠá·áŸáŸá’áŠáŸ„á™á¢áŸ’á“á€á‚áŸ’ášá”áŸ‹á‚áŸ’ášá„áŸ”\n\n"
                     f"áŸá¼á˜á‘á¶á€áŸ‹á‘á„á¢áŸ’á“á€á‚áŸ’ášá”áŸ‹á‚áŸ’ášá„áŸá˜áŸ’ášá¶á”áŸ‹á–áŸááŸŒá˜á¶á“á”á“áŸ’ááŸ‚á˜áŸ”",
                parse_mode='Markdown'
            )
        except TelegramError as e:
            logger.warning(f"Failed to notify user {target_user_id} about rejected deposit {code}. Error: {e}")
            await query.answer(f"User {target_user_id} might have blocked the bot. Could not notify.", show_alert=True)
            
        final_admin_text = (
            f"âŒ <b>á”á¶á“á”áŠá·áŸáŸá’ (áŠáŸ„á™ {admin_user.full_name})</b>\n\n"
            f"<b>á¢áŸ’á“á€á”áŸ’ášá¾á”áŸ’ášá¶áŸáŸ‹:</b> {full_name} (ID: <code>{target_user_id}</code>)\n"
            f"<b>á…áŸ†á“á½á“:</b> <code>${amount:.2f} USD</code>\n"
            f"<b>Transaction Code:</b> <code>{code}</code>\n"
            f"<b>MD5:</b> <code>{md5_hash}</code>"
        )
        try:
            await query.edit_message_text(text=final_admin_text, parse_mode='HTML', reply_markup=None) # <--- Changed to HTML
        except BadRequest:
            await context.bot.send_message(
                chat_id=update.effective_chat.id,
                text=final_admin_text, parse_mode='HTML', reply_markup=None
            )

    # á›á»á” pending deposit á“á·á„ jobs áŠáŸ‚á›á–á¶á€áŸ‹á–áŸá“áŸ’á’
    if code in context.bot_data['pending_deposits']:
        del context.bot_data['pending_deposits'][code]
        for job in context.job_queue.get_jobs_by_name(f"md5_check_{code}"):
            job.schedule_removal()
        for job in context.job_queue.get_jobs_by_name(f"timeout_job_{code}"):
            job.schedule_removal()

    return ConversationHandler.END

async def cancel_deposit(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Cancels a deposit conversation flow."""
    message = "âŒ á€á¶ášáŠá¶á€áŸ‹á”áŸ’ášá¶á€áŸ‹ááŸ’ášá¼áœá”á¶á“á”áŸ„áŸ‡á”á„áŸ‹áŸ”"
    if update.callback_query:
        if update.callback_query.message:
            try:
                await update.callback_query.message.edit_text(text=message, parse_mode='Markdown')
            except BadRequest:
                await context.bot.send_message(chat_id=update.effective_chat.id, text=message, reply_markup=ReplyKeyboardRemove(), parse_mode='Markdown')
        else:
            await update.callback_query.answer()
            await context.bot.send_message(chat_id=update.effective_chat.id, text=message, reply_markup=ReplyKeyboardRemove(), parse_mode='Markdown')
    elif update.message:
        await update.message.reply_text(text=message, reply_markup=ReplyKeyboardRemove(), parse_mode='Markdown')
    
    # After canceling deposit, return to the main menu keyboard
    await context.bot.send_message(
        chat_id=update.effective_chat.id,
        text="áŸá¼á˜á‡áŸ’ášá¾áŸášá¾áŸá‡á˜áŸ’ášá¾áŸáá¶á„á€áŸ’ášáŸ„á˜áŸ–",
        reply_markup=await get_main_menu_keyboard(),
        parse_mode='Markdown'
    )
    context.user_data.clear()
    return ConversationHandler.END


# --- á˜á»áá„á¶ášá”á„áŸ’á á¶á‰á”áŸ’ášáœááŸ’áá·á”á‰áŸ’á‡á¶á‘á·á‰ ---
async def show_order_history(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """á”á„áŸ’á á¶á‰á”áŸ’ášáœááŸ’áá·á€á¶ášá”á‰áŸ’á‡á¶á‘á·á‰ (à¸–à¸¹à¸à¹€à¸£à¸µà¸¢à¸á–á¸ MessageHandler)"""
    user_id = update.effective_user.id

    user_data = user_accounts.get(user_id)
    back_button_keyboard = InlineKeyboardMarkup([[InlineKeyboardButton(BTN_BACK_TO_MAIN_MENU, callback_data='start_menu')]])

    if not user_data or not user_data.get("orders"):
        await update.message.reply_text(
            text="âŒ á¢áŸ’á“á€á˜á·á“á‘á¶á“áŸ‹á˜á¶á“á”áŸ’ášáœááŸ’áá·á”á‰áŸ’á‡á¶á‘á·á‰á“áŸ…á¡á¾á™á‘áŸáŸ”",
            reply_markup=back_button_keyboard,
            parse_mode='Markdown'
        )
        return

    orders = user_data["orders"]
    recent_orders = list(reversed(orders))[:10]

    history_text = "ğŸ“œ **á”áŸ’ášáœááŸ’áá·á”á‰áŸ’á‡á¶á‘á·á‰ (10 á…á»á„á€áŸ’ášáŸ„á™)** ğŸ“œ\n"
    history_text += "----------------------------------\n\n"
    for order in recent_orders:
        remaining_balance_val = order.get('remaining_balance')
        remaining_balance_str = f"**{remaining_balance_val:.2f}$**" if remaining_balance_val is not None else "**N/A**"

        history_text += (
            f"â–ªï¸ áŸáŸáœá¶á€á˜áŸ’á˜áŸ– **{order.get('service_name', 'N/A')}**\n"
            f"â–ªï¸ Order ID: `{order.get('smm_order_id', 'N/A')}`\n"
            f"â–ªï¸ LinkáŸ– `{order.get('link', 'N/A')}`\n"
            f"â–ªï¸ á‘á¹á€á”áŸ’ášá¶á€áŸ‹á€á¶ááŸ‹á…áŸ†á“á½á“: **{order.get('cost', 0):.2f}$**\n"
            f"â–ªï¸ á‘á¹á€á”áŸ’ášá¶á€áŸ‹á“áŸ…áŸá›áŸ‹áŸ– {remaining_balance_str}\n"
            f"â–ªï¸ ááŸ’á„áŸƒ ááŸ‚ á†áŸ’á“á¶áŸ†áŸ– `{order.get('timestamp', 'N/A')}`\n"
            f"----------------------------------\n"
        )

    await update.message.reply_text(
        text=history_text,
        reply_markup=back_button_keyboard,
        parse_mode='Markdown'
    )


# --- á˜á»áá„á¶áš User Order Flow (ConversationHandler) ---
async def select_service_to_buy(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    parts = query.data.split('_')
    platform_name = parts[2]
    service_id = parts[3]

    selected_service = next((s for s in services_data.get(platform_name, []) if s['id'] == service_id), None)

    if not selected_service or "smm_service_id" not in selected_service:
        await query.edit_message_text("âŒ áŸáŸáœá¶á€á˜áŸ’á˜á“áŸáŸ‡á˜á·á“á˜á¶á“á‘áŸ€áá‘áŸáŸ”")
        return ConversationHandler.END

    context.user_data['order_platform'] = platform_name
    context.user_data['order_service'] = selected_service

    try:
        await query.edit_message_text(
            f"á¢áŸ’á“á€á”á¶á“á‡áŸ’ášá¾áŸášá¾áŸáŸ–\n**{selected_service['name']}**\náá˜áŸ’á›áŸƒáŸ– **{selected_service['price_per_k']}$ / 1000**\n\n"
            f"áŸá¼á˜áœá¶á™á”á‰áŸ’á…á¼á›á…áŸ†á“á½á“áŠáŸ‚á›á¢áŸ’á“á€á…á„áŸ‹á‘á·á‰áŸ– (á§. `1000`)\n\náœá¶á™ /cancel áŠá¾á˜áŸ’á”á¸á”áŸ„áŸ‡á”á„áŸ‹áŸ”",
            parse_mode='Markdown'
        )
    except BadRequest: # If message was already deleted or too old
        await context.bot.send_message(
            chat_id=update.effective_chat.id,
            text=f"á¢áŸ’á“á€á”á¶á“á‡áŸ’ášá¾áŸášá¾áŸáŸ–\n**{selected_service['name']}**\náá˜áŸ’á›áŸƒáŸ– **{selected_service['price_per_k']}$ / 1000**\n\n"
                 f"áŸá¼á˜áœá¶á™á”á‰áŸ’á…á¼á›á…áŸ†á“á½á“áŠáŸ‚á›á¢áŸ’á“á€á…á„áŸ‹á‘á·á‰áŸ– (á§. `1000`)\n\náœá¶á™ /cancel áŠá¾á˜áŸ’á”á¸á”áŸ„áŸ‡á”á„áŸ‹áŸ”",
            parse_mode='Markdown'
        )

    return RECEIVE_QUANTITY

async def receive_quantity_then_ask_link(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        quantity = int(update.message.text.strip())
        if quantity <= 0: raise ValueError()
    except ValueError:
        await update.message.reply_text("á…áŸ†á“á½á“á˜á·á“ááŸ’ášá¹á˜ááŸ’ášá¼áœá‘áŸáŸ” áŸá¼á˜áœá¶á™á”á‰áŸ’á…á¼á›á‡á¶á›áŸááœá·á‡áŸ’á‡á˜á¶á“ (á§. `1000`) á¬ /cancel áŠá¾á˜áŸ’á”á¸á”áŸ„áŸ‡á”á„áŸ‹áŸ”", parse_mode='Markdown')
        return RECEIVE_QUANTITY

    context.user_data['order_quantity'] = quantity

    await update.message.reply_text(
        "áŸá¼á˜á•áŸ’á‰á¾ **Link** áŸá˜áŸ’ášá¶á”áŸ‹áŸáŸáœá¶á€á˜áŸ’á˜á“áŸáŸ‡áŸ–\n\náœá¶á™ /cancel áŠá¾á˜áŸ’á”á¸á”áŸ„áŸ‡á”á„áŸ‹áŸ”",
        parse_mode='Markdown'
    )
    return RECEIVE_LINK

async def receive_link_and_confirm_order(update: Update, context: ContextTypes.DEFAULT_TYPE):
    platform_link = update.message.text.strip()
    if not platform_link.startswith(('http://', 'https://')):
        await update.message.reply_text("Link á˜á·á“ááŸ’ášá¹á˜ááŸ’ášá¼áœáŸ” áŸá¼á˜á•áŸ’á‰á¾ Link ááŸ’ášá¹á˜ááŸ’ášá¼áœ (á§. `https://example.com/post`) á¬ /cancel áŠá¾á˜áŸ’á”á¸á”áŸ„áŸ‡á”á„áŸ‹áŸ”", parse_mode='Markdown')
        return RECEIVE_LINK # Keep user in this state until valid link is provided

    context.user_data['order_link'] = platform_link

    user_id = update.effective_user.id
    selected_service = context.user_data['order_service']
    quantity = context.user_data['order_quantity']
    price_per_k = selected_service['price_per_k']
    total_cost = (quantity / 1000) * price_per_k

    user_balance = user_accounts.get(user_id, {}).get("balance", 0)

    context.user_data['order_cost'] = total_cost

    if user_balance < total_cost:
        await update.message.reply_text(
            f"âŒ **á‘á¹á€á”áŸ’ášá¶á€áŸ‹á˜á·á“á‚áŸ’ášá”áŸ‹á‚áŸ’ášá¶á“áŸ‹!**\n\n"
            f"á‘á¹á€á”áŸ’ášá¶á€áŸ‹á”á…áŸ’á…á»á”áŸ’á”á“áŸ’á“: **{user_balance:.2f}$**\n"
            f"áá˜áŸ’á›áŸƒáŸáŸáœá¶á€á˜áŸ’á˜: **{total_cost:.2f}$**\n\n"
            f"áŸá¼á˜áŠá¶á€áŸ‹á”áŸ’ášá¶á€áŸ‹á”á“áŸ’ááŸ‚á˜áŠá¾á˜áŸ’á”á¸á”á“áŸ’ááŸ”",
            parse_mode='Markdown'
        )
        return ConversationHandler.END

    message_text = (
        f"**áŸá¼á˜á”á‰áŸ’á‡á¶á€áŸ‹á€á¶ášá”á‰áŸ’á‡á¶á‘á·á‰ášá”áŸáŸ‹á¢áŸ’á“á€**\n\n"
        f"â–ªï¸ áŸáŸáœá¶á€á˜áŸ’á˜áŸ– **{selected_service['name']}**\n"
        f"â–ªï¸ á…áŸ†á“á½á“áŸ– **{quantity}**\n"
        f"â–ªï¸ LinkáŸ– `{platform_link}`\n"
        f"----------------------------------\n"
        f"â–ªï¸ áá˜áŸ’á›áŸƒáŸášá»á”áŸ– **{total_cost:.2f}$ USD**\n"
        f"â–ªï¸ á‘á¹á€á”áŸ’ášá¶á€áŸ‹á”á…áŸ’á…á»á”áŸ’á”á“áŸ’á“áŸ– **{user_balance:.2f}$ USD**\n"
        f"â–ªï¸ á‘á¹á€á”áŸ’ášá¶á€áŸ‹á“áŸ…áŸá›áŸ‹ (á€áŸ’ášáŸ„á™á‘á·á‰)áŸ– **{(user_balance - total_cost):.2f}$ USD**\n\n"
        f"áá¾á¢áŸ’á“á€á–á·áá‡á¶á…á„áŸ‹á”á‰áŸ’á‡á¶á‘á·á‰á˜áŸ‚á“á‘áŸ?"
    )

    keyboard = [
        [InlineKeyboardButton("ğŸ›’ á”á‰áŸ’á‡á¶á‘á·á‰á¥á¡á¼áœá“áŸáŸ‡", callback_data='confirm_order')],
        [InlineKeyboardButton("âŒ á”áŸ„áŸ‡á”á„áŸ‹", callback_data='cancel_order')]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)

    await update.message.reply_text(message_text, reply_markup=reply_markup, parse_mode='Markdown')

    return CONFIRM_ORDER_AND_PAY

async def process_and_deduct_balance(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    if query.data == 'cancel_order':
        await query.edit_message_text("âŒ á€á¶ášá”á‰áŸ’á‡á¶á‘á·á‰ááŸ’ášá¼áœá”á¶á“á”áŸ„áŸ‡á”á„áŸ‹áŸ”", parse_mode='Markdown')
        context.user_data.clear()
        return ConversationHandler.END

    try:
        await query.edit_message_text("ğŸ”„ á€áŸ†á–á»á„áŠáŸ†áá¾ášá€á¶ášá”á‰áŸ’á‡á¶á‘á·á‰... áŸá¼á˜ášá„áŸ‹á…á¶áŸ†áŸ”", parse_mode='Markdown')
    except BadRequest:
        await context.bot.send_message(
            chat_id=update.effective_chat.id,
            text="ğŸ”„ á€áŸ†á–á»á„áŠáŸ†áá¾ášá€á¶ášá”á‰áŸ’á‡á¶á‘á·á‰... áŸá¼á˜ášá„áŸ‹á…á¶áŸ†áŸ”", parse_mode='Markdown'
        )

    user_id = update.effective_user.id
    cost = context.user_data.get('order_cost')
    selected_service = context.user_data.get('order_service', {})
    smm_service_id = selected_service.get('smm_service_id')
    link = context.user_data.get('order_link')
    quantity = context.user_data.get('order_quantity')

    user_balance = user_accounts.get(user_id, {}).get("balance", 0)
    if user_balance < cost or not all([cost, smm_service_id, link, quantity]):
        try:
            await query.edit_message_text("âŒ á˜á¶á“á”á‰áŸ’á á¶áŸ” á‘á¹á€á”áŸ’ášá¶á€áŸ‹á˜á·á“á‚áŸ’ášá”áŸ‹á‚áŸ’ášá¶á“áŸ‹ á¬á‘á·á“áŸ’á“á“áŸá™á”á‰áŸ’á‡á¶á‘á·á‰á”á¶ááŸ‹á”á„áŸ‹áŸ”", parse_mode='Markdown')
        except BadRequest:
            await context.bot.send_message(
                chat_id=update.effective_chat.id,
                text="âŒ á˜á¶á“á”á‰áŸ’á á¶áŸ” á‘á¹á€á”áŸ’ášá¶á€áŸ‹á˜á·á“á‚áŸ’ášá”áŸ‹á‚áŸ’ášá¶á“áŸ‹ á¬á‘á·á“áŸ’á“á“áŸá™á”á‰áŸ’á‡á¶á‘á·á‰á”á¶ááŸ‹á”á„áŸ‹áŸ”", parse_mode='Markdown'
            )
        context.user_data.clear()
        return ConversationHandler.END

    user_accounts[user_id]["balance"] -= cost
    remaining_balance = user_accounts[user_id]['balance']

    smm_response = await smm_client.add_order(smm_service_id, link, quantity)

    if smm_response.get("success"):
        smm_order_id = smm_response['order_id']

        order_timestamp = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S') # Use current time for timestamp
        order_details = {
            "service_name": selected_service['name'],
            "quantity": quantity,
            "link": link,
            "cost": cost,
            "timestamp": order_timestamp,
            "smm_order_id": smm_order_id,
            "remaining_balance": remaining_balance
        }

        if 'orders' not in user_accounts[user_id]:
            user_accounts[user_id]['orders'] = []
        user_accounts[user_id]["orders"].append(order_details)
        user_accounts[user_id]["transactions"].append(f"-{cost:.2f}$ (Order {smm_order_id})")

        try:
            await query.edit_message_text(
                f"âœ… **á€á¶ášá”á‰áŸ’á‡á¶á‘á·á‰á”á¶á“á‡áŸ„á‚á‡áŸá™!**\n\n"
                f"SMM Order ID: `{smm_order_id}`\n"
                f"á‘á¹á€á”áŸ’ášá¶á€áŸ‹ááŸ’ášá¼áœá”á¶á“á€á¶ááŸ‹: **{cost:.2f}$**\n"
                f"á‘á¹á€á”áŸ’ášá¶á€áŸ‹á“áŸ…áŸá›áŸ‹áŸ– **{remaining_balance:.2f}$**",
                parse_mode='Markdown'
            )
        except BadRequest:
            await context.bot.send_message(
                chat_id=update.effective_chat.id,
                text=f"âœ… **á€á¶ášá”á‰áŸ’á‡á¶á‘á·á‰á”á¶á“á‡áŸ„á‚á‡áŸá™!**\n\n"
                     f"SMM Order ID: `{smm_order_id}`\n"
                     f"á‘á¹á€á”áŸ’ášá¶á€áŸ‹ááŸ’ášá¼áœá”á¶á“á€á¶ááŸ‹: **{cost:.2f}$**\n"
                     f"á‘á¹á€á”áŸ’ášá¶á€áŸ‹á“áŸ…áŸá›áŸ‹áŸ– **{remaining_balance:.2f}$**",
                parse_mode='Markdown'
            )

        try:
            notification_message = (
                f"âœ… **á€á¶ášá”á‰áŸ’á‡á¶á‘á·á‰á”á¶á“á‡áŸ„á‚á‡áŸá™!**\n\n"
                f"- áŸáŸáœá¶á€á˜áŸ’á˜áŸ– **{order_details['service_name']}**\n"
                f"- Order ID: `{order_details['smm_order_id']}`\n"
                f"- LinkáŸ– `{order_details['link']}`\n"
                f"- á‘á¹á€á”áŸ’ášá¶á€áŸ‹ášá”áŸáŸ‹á¢áŸ’á“á€ááŸ’ášá¼áœá”á¶á“á€á¶ááŸ‹á…áŸ†á“á½á“: **{order_details['cost']:.2f}$**\n"
                f"- á‘á¹á€á”áŸ’ášá¶á€áŸ‹á“áŸ…áŸá›áŸ‹áŸ– **{remaining_balance:.2f}$**\n"
                f"- ááŸ’á„áŸƒ ááŸ‚ á†áŸ’á“á¶áŸ† á“á·á„ á˜áŸ‰áŸ„á„: `{order_details['timestamp']}`"
            )

            await context.bot.send_message(
                chat_id=TELEGRAM_GROUP_ID,
                text=notification_message,
                parse_mode='Markdown'
            )
            logger.info(f"Sent order notification to group {TELEGRAM_GROUP_ID}.")

        except TelegramError as e:
            logger.error(f"CRITICAL: Failed to send notification to group {TELEGRAM_GROUP_ID}. Error: {e}")

            if ADMIN_USER_IDS:
                admin_id = ADMIN_USER_IDS[0]
                error_message_for_admin = (
                    f"âš ï¸ <b>á”á‰áŸ’á á¶á’áŸ’á„á“áŸ‹á’áŸ’á„áš</b> âš ï¸\n\n"
                    f"Bot á˜á·á“á¢á¶á…á•áŸ’á‰á¾áŸá¶ášá”á‰áŸ’á‡á¶á€áŸ‹á€á¶ášá”á‰áŸ’á‡á¶á‘á·á‰á‘áŸ…á€á¶á“áŸ‹á‚áŸ’ášá»á” ID <code>{TELEGRAM_GROUP_ID}</code> á”á¶á“á‘áŸáŸ”\n\n"
                    f"<b>Error Message á–á¸ Telegram:</b>\n<code>{e}</code>\n\n"
                    f"<b>áŸá¼á˜á–á·á“á·ááŸ’á™á˜á¾á›á‡á¶á”á“áŸ’á‘á¶á“áŸ‹áŸ–</b>\n"
                    f"1. áá¾ Group ID <code>{TELEGRAM_GROUP_ID}</code> ááŸ’ášá¹á˜ááŸ’ášá¼áœ 100% á¬á‘áŸ?\n"
                    f"2. áá¾ Bot ááŸ’ášá¼áœá”á¶á“ Add á‡á¶ <b>Admin</b> á“áŸ…á€áŸ’á“á»á„á‚áŸ’ášá»á”á“áŸ„áŸ‡á á¾á™á¬á“áŸ…?"
                )
                try:
                    await context.bot.send_message(
                        chat_id=admin_id,
                        text=error_message_for_admin,
                        parse_mode='HTML'
                    )
                except Exception as admin_send_error:
                    logger.error(f"FATAL: Could not even send the error report to main admin {admin_id}. Error: {admin_send_error}")

    else:
        user_accounts[user_id]["balance"] += cost # Refund the money
        error_msg = smm_response.get("error", "Unknown error from SMM Panel")
        logger.error(f"SMM Order failed. Refunding {cost}$. Error: {error_msg}")

        try:
            await query.edit_message_text(
                f"âŒ **á€á¶ášá”á‰áŸ’á‡á¶á‘á·á‰á”á¶á“á”ášá¶á‡áŸá™!**\n\n"
                f"á”á‰áŸ’á á¶á–á¸ SMM Panel: `{error_msg}`\n\n"
                f"**á‘á¹á€á”áŸ’ášá¶á€áŸ‹ášá”áŸáŸ‹á¢áŸ’á“á€ááŸ’ášá¼áœá”á¶á“áŸá„ááŸ’ášá›á”áŸ‹á˜á€áœá·á‰áŸ”**",
                parse_mode='Markdown'
            )
        except BadRequest:
            await context.bot.send_message(
                chat_id=update.effective_chat.id,
                text=f"âŒ **á€á¶ášá”á‰áŸ’á‡á¶á‘á·á‰á”á¶á“á”ášá¶á‡áŸá™!**\n\n"
                     f"á”á‰áŸ’á á¶á–á¸ SMM Panel: `{error_msg}`\n\n"
                     f"**á‘á¹á€á”áŸ’ášá¶á€áŸ‹ášá”áŸáŸ‹á¢áŸ’á“á€ááŸ’ášá¼áœá”á¶á“áŸá„ááŸ’ášá›á”áŸ‹á˜á€áœá·á‰áŸ”**",
                parse_mode='Markdown'
            )

    context.user_data.clear()
    return ConversationHandler.END


async def cancel_order_flow(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("âŒ á€á¶ášá”á‰áŸ’á‡á¶á‘á·á‰ááŸ’ášá¼áœá”á¶á“á”áŸ„áŸ‡á”á„áŸ‹áŸ”", reply_markup=await get_main_menu_keyboard(), parse_mode='Markdown')
    context.user_data.clear()
    return ConversationHandler.END


# Helper function to send or edit message from a callback query
async def send_or_edit_message_from_query(query: Update.callback_query, text: str, reply_markup=None, parse_mode='Markdown'):
    try:
        await query.edit_message_text(text=text, reply_markup=reply_markup, parse_mode=parse_mode)
    except BadRequest:
        await query.bot.send_message(chat_id=query.message.chat_id, text=text, reply_markup=reply_markup, parse_mode=parse_mode)

# --- Admin Panel Functions (Entry Points for Conversations) ---

async def admin_add_platform_entry(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    if update.effective_user.id not in ADMIN_USER_IDS:
        await send_or_edit_message_from_query(query, "â›”ï¸ á¢áŸ’á“á€á˜á·á“á˜á¶á“áŸá·á‘áŸ’á’á·á…á¼á›á”áŸ’ášá¾ Admin Panel á‘áŸáŸ”")
        return ConversationHandler.END
    await send_or_edit_message_from_query(query, "áŸá¼á˜áœá¶á™á”á‰áŸ’á…á¼á›áˆáŸ’á˜áŸ„áŸ‡ Platform ááŸ’á˜á¸áŠáŸ‚á›á¢áŸ’á“á€á…á„áŸ‹á”á“áŸ’ááŸ‚á˜áŸ– (á§á‘á¶á ášááŸáŸ– `Twitter`)\n\náœá¶á™ /cancel áŠá¾á˜áŸ’á”á¸á”áŸ„áŸ‡á”á„áŸ‹áŸ”")
    return ADD_PLATFORM_NAME

async def admin_add_service_new_entry(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    if update.effective_user.id not in ADMIN_USER_IDS:
        await send_or_edit_message_from_query(query, "â›”ï¸ á¢áŸ’á“á€á˜á·á“á˜á¶á“áŸá·á‘áŸ’á’á·á…á¼á›á”áŸ’ášá¾ Admin Panel á‘áŸáŸ”")
        return ConversationHandler.END

    if not services_data:
        await send_or_edit_message_from_query(query, "âŒ á˜á·á“á‘á¶á“áŸ‹á˜á¶á“ Platform áá¶á˜á½á™ááŸ’ášá¼áœá”á¶á“á”á“áŸ’ááŸ‚á˜á“áŸ…á¡á¾á™á‘áŸáŸ”\n\náŸá¼á˜á”áŸ’ášá¾á”áŸŠá¼áá»á„ 'á”á“áŸ’ááŸ‚á˜ Platform ááŸ’á˜á¸' á‡á¶á˜á»á“áŸá·á“áŸ”\n\n/admin áŠá¾á˜áŸ’á”á¸ááŸ’ášá¡á”áŸ‹á‘áŸ… Admin Panel áœá·á‰áŸ”")
        return ConversationHandler.END

    platform_keyboard = [[InlineKeyboardButton(f"**{platform}**", callback_data=f'add_service_platform_{platform}')] for platform in services_data.keys()]
    platform_keyboard.append([InlineKeyboardButton("â¬…ï¸ **ááŸ’ášá¡á”áŸ‹**", callback_data='admin_back_to_panel')]) # Back to admin panel
    await send_or_edit_message_from_query(query, "áŸá¼á˜á‡áŸ’ášá¾áŸášá¾áŸ Platform áŠáŸ‚á›á¢áŸ’á“á€á…á„áŸ‹á”á“áŸ’ááŸ‚á˜áŸáŸáœá¶á€á˜áŸ’á˜áŸ–", reply_markup=InlineKeyboardMarkup(platform_keyboard))
    return ADD_SERVICE_PLATFORM

async def admin_delete_all_services_entry(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    if update.effective_user.id not in ADMIN_USER_IDS:
        await send_or_edit_message_from_query(query, "â›”ï¸ á¢áŸ’á“á€á˜á·á“á˜á¶á“áŸá·á‘áŸ’á’á·á…á¼á›á”áŸ’ášá¾á˜á»áá„á¶ášá“áŸáŸ‡á‘áŸáŸ”")
        return ConversationHandler.END

    if not services_data:
        await send_or_edit_message_from_query(query, "âŒ á˜á·á“á‘á¶á“áŸ‹á˜á¶á“áŸáŸáœá¶á€á˜áŸ’á˜áá¶á˜á½á™ááŸ’ášá¼áœá”á¶á“á”á“áŸ’ááŸ‚á˜á“áŸ…á¡á¾á™á‘áŸáŸ”\n\n/admin áŠá¾á˜áŸ’á”á¸ááŸ’ášá¡á”áŸ‹á‘áŸ… Admin Panel áœá·á‰áŸ”")
        return ConversationHandler.END

    keyboard = [
        [InlineKeyboardButton("âœ… **á”á‰áŸ’á‡á¶á€áŸ‹ (á”á¶á‘)**", callback_data='confirm_delete_all_yes')],
        [InlineKeyboardButton("âŒ **á”áŸ„áŸ‡á”á„áŸ‹ (á‘áŸ)**", callback_data='confirm_delete_all_no')]
    ]
    await send_or_edit_message_from_query(
        query,
        "âš ï¸ **á¢áŸ’á“á€á”áŸ’ášá¶á€áŠá‡á¶á…á„áŸ‹á›á»á”áŸáŸáœá¶á€á˜áŸ’á˜á‘á¶áŸ†á„á¢áŸáŸ‹á˜áŸ‚á“á‘áŸ?**\n**á”áŸ’ášáá·á”ááŸ’áá·á€á¶ášá“áŸáŸ‡á˜á·á“á¢á¶á…áŠá€áá™á”á¶á“á‘áŸ!**",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )
    return CONFIRM_DELETE_ALL_SERVICES

async def admin_rename_platform_entry(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    if update.effective_user.id not in ADMIN_USER_IDS:
        await send_or_edit_message_from_query(query, "â›”ï¸ á¢áŸ’á“á€á˜á·á“á˜á¶á“áŸá·á‘áŸ’á’á·á…á¼á›á”áŸ’ášá¾ Admin Panel á‘áŸáŸ”")
        return ConversationHandler.END
    
    if not services_data:
        await send_or_edit_message_from_query(query, "âŒ á˜á·á“á‘á¶á“áŸ‹á˜á¶á“ Platform áá¶á˜á½á™ááŸ’ášá¼áœá”á¶á“á”á“áŸ’ááŸ‚á˜á“áŸ…á¡á¾á™á‘áŸáŸ”\n\n/admin áŠá¾á˜áŸ’á”á¸ááŸ’ášá¡á”áŸ‹á‘áŸ… Admin Panel áœá·á‰áŸ”")
        return ConversationHandler.END

    await send_or_edit_message_from_query(query, "áŸá¼á˜áœá¶á™á”á‰áŸ’á…á¼á›áˆáŸ’á˜áŸ„áŸ‡ Platform á…á¶áŸáŸ‹áŠáŸ‚á›á¢áŸ’á“á€á…á„áŸ‹á€áŸ‚á”áŸ’ášáŸ‚áŸ– (á§á‘á¶á ášááŸáŸ– `Facebook`)\n\náœá¶á™ /cancel áŠá¾á˜áŸ’á”á¸á”áŸ„áŸ‡á”á„áŸ‹áŸ”")
    return RENAME_PLATFORM_OLD_NAME

async def admin_delete_platform_select_entry(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    if update.effective_user.id not in ADMIN_USER_IDS:
        await send_or_edit_message_from_query(query, "â›”ï¸ á¢áŸ’á“á€á˜á·á“á˜á¶á“áŸá·á‘áŸ’á’á·á…á¼á›á”áŸ’ášá¾ Admin Panel á‘áŸáŸ”")
        return ConversationHandler.END

    if not services_data:
        await send_or_edit_message_from_query(query, "âŒ á˜á·á“á‘á¶á“áŸ‹á˜á¶á“ Platform áá¶á˜á½á™ááŸ’ášá¼áœá”á¶á“á”á“áŸ’ááŸ‚á˜á“áŸ…á¡á¾á™á‘áŸáŸ”\n\n/admin áŠá¾á˜áŸ’á”á¸ááŸ’ášá¡á”áŸ‹á‘áŸ… Admin Panel áœá·á‰áŸ”")
        return ConversationHandler.END

    platform_buttons = []
    for platform_name in services_data.keys():
        platform_buttons.append([InlineKeyboardButton(platform_name, callback_data=f'delete_platform_confirm_{platform_name}')])
    
    platform_buttons.append([InlineKeyboardButton("â¬…ï¸ **ááŸ’ášá¡á”áŸ‹**", callback_data='admin_manage_platforms')]) 

    reply_markup = InlineKeyboardMarkup(platform_buttons)
    await send_or_edit_message_from_query(query, "âš ï¸ áŸá¼á˜á‡áŸ’ášá¾áŸášá¾áŸ Platform áŠáŸ‚á›á¢áŸ’á“á€á…á„áŸ‹á›á»á”áŸ–\n\n**á€á¶ášá›á»á” Platform á“á¹á„á›á»á”áŸáŸáœá¶á€á˜áŸ’á˜á‘á¶áŸ†á„á¢áŸáŸ‹áŠáŸ‚á›á‡á¶á”áŸ‹á‡á¶á˜á½á™á•á„áŠáŸ‚áš!**", reply_markup=reply_markup)
    return DELETE_PLATFORM_NAME


# Admin Panel Main Handlers
async def admin_panel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    if user_id not in ADMIN_USER_IDS:
        if update.message:
            await update.message.reply_text("â›”ï¸ á¢áŸ’á“á€á˜á·á“á˜á¶á“áŸá·á‘áŸ’á’á·á…á¼á›á”áŸ’ášá¾ Admin Panel á‘áŸáŸ”", parse_mode='Markdown')
        elif update.callback_query:
            await update.callback_query.answer("â›”ï¸ á¢áŸ’á“á€á˜á·á“á˜á¶á“áŸá·á‘áŸ’á’á·á…á¼á›á”áŸ’ášá¾ Admin Panel á‘áŸáŸ”", show_alert=True)
            try:
                await update.callback_query.message.edit_text("â›”ï¸ á¢áŸ’á“á€á˜á·á“á˜á¶á“áŸá·á‘áŸ’á’á·á…á¼á›á”áŸ’ášá¾ Admin Panel á‘áŸáŸ”", parse_mode='Markdown')
            except BadRequest: 
                await context.bot.send_message(chat_id=update.effective_chat.id, text="â›”ï¸ á¢áŸ’á“á€á˜á·á“á˜á¶á“áŸá·á‘áŸ’á’á·á…á¼á›á”áŸ’ášá¾ Admin Panel á‘áŸáŸ”", parse_mode='Markdown')
        return ConversationHandler.END 

    keyboard = [
        [InlineKeyboardButton("ğŸ“Š **á˜á¾á›á‘á·á“áŸ’á“á“áŸá™áŸáŸáœá¶á€á˜áŸ’á˜**", callback_data='admin_view_services')],
        [InlineKeyboardButton("â• **á‚áŸ’ášá”áŸ‹á‚áŸ’ášá„ Platforms**", callback_data='admin_manage_platforms')], 
        [InlineKeyboardButton("â• **á”á“áŸ’ááŸ‚á˜áŸáŸáœá¶á€á˜áŸ’á˜ááŸ’á˜á¸**", callback_data='admin_add_service_new')], 
        [InlineKeyboardButton("ğŸ’° **á‚áŸ’ášá”áŸ‹á‚áŸ’ášá„á‘á¹á€á”áŸ’ášá¶á€áŸ‹á¢áŸ’á“á€á”áŸ’ášá¾á”áŸ’ášá¶áŸáŸ‹**", callback_data='admin_manage_balance_main')],
        [InlineKeyboardButton("ğŸ“¢ **á•áŸ’á‰á¾áŸá¶ášá‘áŸ…á¢áŸ’á“á€á”áŸ’ášá¾á”áŸ’ášá¶áŸáŸ‹**", callback_data='admin_broadcast')],
        [InlineKeyboardButton("ğŸ“¡ **SMM Panel Tools**", callback_data='admin_smm_tools')],
        [InlineKeyboardButton("â¬…ï¸ **á…áŸá‰á–á¸ Admin Panel**", callback_data='start_menu')] 
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    if update.message:
        await update.message.reply_text(
            "ğŸ‘‹ áŸá¼á˜áŸáŸ’áœá¶á‚á˜á“áŸá˜á€á€á¶á“áŸ‹ Admin Panel!", reply_markup=reply_markup, parse_mode='Markdown'
        )
    elif update.callback_query:
        await update.callback_query.answer() 
        try:
            await update.callback_query.message.edit_text(
                "ğŸ‘‹ áŸá¼á˜áŸáŸ’áœá¶á‚á˜á“áŸá˜á€á€á¶á“áŸ‹ Admin Panel!", reply_markup=reply_markup, parse_mode='Markdown'
            )
        except BadRequest: 
            await context.bot.send_message(
                chat_id=update.effective_chat.id,
                text="ğŸ‘‹ áŸá¼á˜áŸáŸ’áœá¶á‚á˜á“áŸá˜á€á€á¶á“áŸ‹ Admin Panel!", reply_markup=reply_markup, parse_mode='Markdown'
            )

    context.user_data.clear()
    return ConversationHandler.END


# --- Admin Platform/Service Management Handlers (These are menus, not conversation entry points themselves) ---
async def admin_manage_platforms(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    user_id = update.effective_user.id
    if user_id not in ADMIN_USER_IDS:
        await query.edit_message_text("â›”ï¸ á¢áŸ’á“á€á˜á·á“á˜á¶á“áŸá·á‘áŸ’á’á·á…á¼á›á”áŸ’ášá¾ Admin Panel á‘áŸáŸ”", parse_mode='Markdown')
        return ConversationHandler.END

    keyboard = [
        [InlineKeyboardButton("â• **á”á“áŸ’ááŸ‚á˜ Platform ááŸ’á˜á¸**", callback_data='admin_add_platform')],
        [InlineKeyboardButton("âœï¸ **á€áŸ‚á”áŸ’ášáŸ‚áˆáŸ’á˜áŸ„áŸ‡ Platform**", callback_data='admin_rename_platform')], 
        [InlineKeyboardButton("ğŸ—‘ï¸ **á›á»á” Platform á…áŸá‰**", callback_data='admin_delete_platform_select')],
        # Service-specific management options now under "á‚áŸ’ášá”áŸ‹á‚áŸ’ášá„ Platforms"
        [InlineKeyboardButton("ğŸ“ **á€áŸ‚á”áŸ’ášáŸ‚áŸáŸáœá¶á€á˜áŸ’á˜**", callback_data='admin_edit_service_info')], 
        [InlineKeyboardButton("ğŸ—‘ï¸ **á›á»á”áŸáŸáœá¶á€á˜áŸ’á˜ááŸ‚á˜á½á™**", callback_data='admin_delete_single_service')], 
        [InlineKeyboardButton("ğŸ”¥ **á›á»á”áŸáŸáœá¶á€á˜áŸ’á˜á‘á¶áŸ†á„á¢áŸáŸ‹**", callback_data='admin_delete_all_services')], 
        [InlineKeyboardButton("â¬…ï¸ **ááŸ’ášá¡á”áŸ‹á‘áŸ… Admin Panel**", callback_data='admin_back_to_panel')]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await query.edit_message_text("âš™ï¸ áŸá¼á˜á‡áŸ’ášá¾áŸášá¾áŸá‡á˜áŸ’ášá¾áŸá‚áŸ’ášá”áŸ‹á‚áŸ’ášá„ Platform á“á·á„áŸáŸáœá¶á€á˜áŸ’á˜áŸ–", reply_markup=reply_markup, parse_mode='Markdown')
    return ConversationHandler.END 


async def admin_delete_platform_confirm(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    platform_to_delete = query.data.replace('delete_platform_confirm_', '')

    context.user_data['platform_to_delete'] = platform_to_delete

    keyboard = [
        [InlineKeyboardButton(f"âœ… **á”á‰áŸ’á‡á¶á€áŸ‹á›á»á” {platform_to_delete}**", callback_data=f'confirm_delete_platform_yes_{platform_to_delete}')],
        [InlineKeyboardButton("âŒ **á”áŸ„áŸ‡á”á„áŸ‹**", callback_data='confirm_delete_platform_no')]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await query.edit_message_text(
        f"âš ï¸ **á¢áŸ’á“á€á–á·áá‡á¶á…á„áŸ‹á›á»á” Platform '{platform_to_delete}' á“á·á„áŸáŸáœá¶á€á˜áŸ’á˜á‘á¶áŸ†á„á¢áŸáŸ‹ášá”áŸáŸ‹áœá¶á˜áŸ‚á“á‘áŸ?**\n\n"
        f"**á”áŸ’ášáá·á”ááŸ’áá·á€á¶ášá“áŸáŸ‡á˜á·á“á¢á¶á…áŠá€áá™á”á¶á“á‘áŸ!**",
        reply_markup=reply_markup,
        parse_mode='Markdown'
    )
    return CONFIRM_DELETE_PLATFORM 


async def admin_delete_platform_execute(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    platform_to_delete = context.user_data.get('platform_to_delete')

    if query.data.startswith('confirm_delete_platform_yes_'):
        if platform_to_delete in services_data:
            del services_data[platform_to_delete]
            await query.edit_message_text(f"ğŸ—‘ï¸ **á”á¶á“á›á»á” Platform '{platform_to_delete}' á“á·á„áŸáŸáœá¶á€á˜áŸ’á˜á‘á¶áŸ†á„á¢áŸáŸ‹ášá”áŸáŸ‹áœá¶áŠáŸ„á™á‡áŸ„á‚á‡áŸá™áŸ”**\n\n/admin", parse_mode='Markdown')
        else:
            await query.edit_message_text(f"âŒ Platform '{platform_to_delete}' á˜á·á“á˜á¶á“á‘áŸáŸ” á”áŸ’ášá áŸ‚á›á‡á¶ááŸ’ášá¼áœá”á¶á“á›á»á”ášá½á…á á¾á™áŸ”\n\n/admin", parse_mode='Markdown')
    else: # confirm_delete_platform_no
        await query.edit_message_text(f"âŒ á€á¶ášá›á»á” Platform '{platform_to_delete}' ááŸ’ášá¼áœá”á¶á“á”áŸ„áŸ‡á”á„áŸ‹áŸ”\n\n/admin", parse_mode='Markdown')
    
    context.user_data.clear()
    return ConversationHandler.END


async def admin_button_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    Handles general admin button clicks that do NOT start a multi-step conversation.
    For buttons that start conversations, separate entry point functions are used.
    """
    query = update.callback_query
    await query.answer()
    user_id = update.effective_user.id

    if user_id not in ADMIN_USER_IDS:
        try:
            await query.edit_message_text("â›”ï¸ á¢áŸ’á“á€á˜á·á“á˜á¶á“áŸá·á‘áŸ’á’á·á…á¼á›á”áŸ’ášá¾ Admin Panel á‘áŸáŸ”", parse_mode='Markdown')
        except BadRequest:
            await context.bot.send_message(chat_id=update.effective_chat.id, text="â›”ï¸ á¢áŸ’á“á€á˜á·á“á˜á¶á“áŸá·á‘áŸ’á’á·á…á¼á›á”áŸ’ášá¾ Admin Panel á‘áŸáŸ”", parse_mode='Markdown')
        return ConversationHandler.END

    # Consolidate message sending/editing logic to reduce repetition
    async def send_or_edit_message(text, reply_markup=None, parse_mode='Markdown'):
        try:
            await query.edit_message_text(text=text, reply_markup=reply_markup, parse_mode=parse_mode)
        except BadRequest:
            await context.bot.send_message(chat_id=update.effective_chat.id, text=text, reply_markup=reply_markup, parse_mode=parse_mode)

    if query.data == 'admin_view_services':
        message_text = "ğŸ“Š á‘á·á“áŸ’á“á“áŸá™áŸáŸáœá¶á€á˜áŸ’á˜á”á…áŸ’á…á»á…á»á”á“áŸ’á“:\n\n"
        if not services_data: message_text += "    _(á˜á·á“á‘á¶á“áŸ‹á˜á¶á“ Platform á¬áŸáŸáœá¶á€á˜áŸ’á˜)_\n"
        else:
            for platform, services in services_data.items():
                message_text += f"**{platform}**:\n"
                if services:
                    for service in services:
                        smm_id_info = f" (SMM ID: `{service['smm_service_id']}`)" if "smm_service_id" in service else ""
                        message_text += f"    â–ªï¸ `{service['id']}`: {service['name']} ({service['price_per_k']}$/1K){smm_id_info}\n"
                else: message_text += "    _(á˜á·á“á‘á¶á“áŸ‹á˜á¶á“áŸáŸáœá¶á€á˜áŸ’á˜)_\n"
        message_text += "\n\n/admin áŠá¾á˜áŸ’á”á¸ááŸ’ášá¡á”áŸ‹á‘áŸ… Admin Panel áœá·á‰áŸ”"
        await send_or_edit_message(message_text, parse_mode='Markdown')
        # Return ConversationHandler.END if this is a final display, otherwise return next state
        return ConversationHandler.END

    elif query.data == 'admin_manage_platforms': 
        await admin_manage_platforms(update, context)
        return ConversationHandler.END 

    elif query.data == 'admin_manage_balance_main': 
        keyboard = [
            [InlineKeyboardButton("â• **1. áŠá¶á€áŸ‹á”áŸ’ášá¶á€áŸ‹áá¶á˜ ID**", callback_data='admin_deposit_by_id')],
            [InlineKeyboardButton("â– **2. á€á¶ááŸ‹á”á“áŸ’áá™á”áŸ’ášá¶á€áŸ‹áá¶á˜ ID (Command)**", callback_data='admin_deduct_by_id')],
            [InlineKeyboardButton("â¬…ï¸ **ááŸ’ášá¡á”áŸ‹**", callback_data='admin_back_to_panel')]
        ]
        await send_or_edit_message("áŸá¼á˜á‡áŸ’ášá¾áŸášá¾áŸá‡á˜áŸ’ášá¾áŸá‚áŸ’ášá”áŸ‹á‚áŸ’ášá„á‘á¹á€á”áŸ’ášá¶á€áŸ‹áŸ–", reply_markup=InlineKeyboardMarkup(keyboard), parse_mode='Markdown')
        # This is a menu, so it ends the current flow but doesn't necessarily start a new conversation state itself.
        # It just presents new inline buttons.

    elif query.data == 'admin_smm_tools':
        keyboard = [
            [InlineKeyboardButton("ğŸ’² **á†áŸ‚á€á‘á¹á€á”áŸ’ášá¶á€áŸ‹ SMM Panel**", callback_data='admin_check_smm_balance')],
            [InlineKeyboardButton("â¬…ï¸ **ááŸ’ášá¡á”áŸ‹**", callback_data='admin_back_to_panel')]
        ]
        await send_or_edit_message("áŸá¼á˜á‡áŸ’ášá¾áŸášá¾áŸ SMM Panel ToolsáŸ–", reply_markup=InlineKeyboardMarkup(keyboard), parse_mode='Markdown')
        # This is a menu.

    elif query.data == 'admin_check_smm_balance':
        await check_smm_balance_cmd(update, context) # This function will send its own message.
        return ConversationHandler.END 

    elif query.data == 'admin_deposit_by_id': 
        # This is now handled by admin_deposit_by_id_entry as a direct entry point to a conversation.
        # If it somehow gets here, it's a fallback.
        await send_or_edit_message("áŸá¼á˜áœá¶á™á”á‰áŸ’á…á¼á› **User ID** áŠáŸ‚á›á¢áŸ’á“á€á…á„áŸ‹áŠá¶á€áŸ‹á”áŸ’ášá¶á€áŸ‹áŸ–\n\náœá¶á™ /cancel áŠá¾á˜áŸ’á”á¸á”áŸ„áŸ‡á”á„áŸ‹áŸ”", parse_mode='Markdown')
        return ASK_USER_ID_FOR_DEPOSIT # Still needs to return a state if handled here.

    elif query.data == 'admin_deduct_by_id': 
        await send_or_edit_message(text="âš ï¸ áŸá˜áŸ’ášá¶á”áŸ‹á€á¶ááŸ‹á”á“áŸ’áá™á‘á¹á€á”áŸ’ášá¶á€áŸ‹ áŸá¼á˜á”áŸ’ášá¾á–á¶á€áŸ’á™á”á‰áŸ’á‡á¶:\n`/deductbalance <UserID> <Amount>`\n\n/admin áŠá¾á˜áŸ’á”á¸ááŸ’ášá¡á”áŸ‹á‘áŸ… Admin Panel áœá·á‰áŸ”", parse_mode='Markdown')
        return ConversationHandler.END

    elif query.data == 'admin_edit_service_info': 
        await send_or_edit_message(text="âš ï¸ áŸá˜áŸ’ášá¶á”áŸ‹á€áŸ‚á”áŸ’ášáŸ‚áŸáŸáœá¶á€á˜áŸ’á˜ áŸá¼á˜á”áŸ’ášá¾á–á¶á€áŸ’á™á”á‰áŸ’á‡á¶:\n`/editservice <Platform> <Service ID> <New Service Name> <New Price Per 1K> <New SMM Service ID>`\n\n/admin áŠá¾á˜áŸ’á”á¸ááŸ’ášá¡á”áŸ‹á‘áŸ… Admin Panel áœá·á‰áŸ”", parse_mode='Markdown')
        return ConversationHandler.END

    elif query.data == 'admin_delete_single_service': 
        await send_or_edit_message(text="âš ï¸ áŸá˜áŸ’ášá¶á”áŸ‹á›á»á”áŸáŸáœá¶á€á˜áŸ’á˜ááŸ‚á˜á½á™ áŸá¼á˜á”áŸ’ášá¾á–á¶á€áŸ’á™á”á‰áŸ’á‡á¶:\n`/deleteservice <Platform> <Service ID>`\n\n/admin áŠá¾á˜áŸ’á”á¸ááŸ’ášá¡á”áŸ‹á‘áŸ… Admin Panel áœá·á‰áŸ”", parse_mode='Markdown')
        return ConversationHandler.END

    elif query.data == 'admin_broadcast':
        await send_or_edit_message(text="ğŸ“¢ á˜á»áá„á¶ášá•áŸ’á‰á¾áŸá¶ášá‘áŸ…á¢áŸ’á“á€á”áŸ’ášá¾á”áŸ’ášá¶áŸáŸ‹á‘á¶áŸ†á„á¢áŸáŸ‹:\n\náŸá¼á˜á”áŸ’ášá¾á–á¶á€áŸ’á™á”á‰áŸ’á‡á¶:\n`/broadcast <Your Message>`\n\n/admin áŠá¾á˜áŸ’á”á¸ááŸ’ášá¡á”áŸ‹á‘áŸ… Admin Panel áœá·á‰áŸ”", parse_mode='Markdown')
        return ConversationHandler.END

    elif query.data == 'admin_back_to_panel':
        await admin_panel(update, context) 
        return ConversationHandler.END

    elif query.data == 'start_menu': 
        await start(update, context)
        return ConversationHandler.END

    # If an unexpected callback data is received by this general handler, log it.
    logger.warning(f"Admin button handler received unhandled callback_data: {query.data}")
    return ConversationHandler.END


async def received_platform_name(update: Update, context: ContextTypes.DEFAULT_TYPE):
    new_platform_name = update.message.text.strip()
    if len(new_platform_name.split(' ', 1)) > 1 and new_platform_name.split(' ', 1)[0] in ["âš«ï¸", "ğŸ”´", "ğŸ”µ", "ğŸŸ£", "ğŸŸ¢", "ğŸŸ¡"]:
        new_platform_name_clean = new_platform_name.split(' ', 1)[1]
    else:
        new_platform_name_clean = new_platform_name

    if new_platform_name_clean.lower() in [key.lower() for key in services_data.keys()]:
        await update.message.reply_text(f"Platform '**{new_platform_name_clean}**' á˜á¶á“ášá½á…á á¾á™áŸ” áŸá¼á˜áŸá¶á€á›áŸ’á”á„áˆáŸ’á˜áŸ„áŸ‡á•áŸ’áŸáŸá„á‘áŸ€á á¬áœá¶á™ /cancel áŠá¾á˜áŸ’á”á¸á”áŸ„áŸ‡á”á„áŸ‹áŸ”", parse_mode='Markdown')
        return ADD_PLATFORM_NAME

    services_data[new_platform_name_clean] = []
    await update.message.reply_text(f"âœ… á”á¶á“á”á“áŸ’ááŸ‚á˜ Platform '**{new_platform_name_clean}**' áŠáŸ„á™á‡áŸ„á‚á‡áŸá™áŸ”\n\n/admin áŠá¾á˜áŸ’á”á¸ááŸ’ášá¡á”áŸ‹á‘áŸ… Admin Panel áœá·á‰áŸ”", parse_mode='Markdown')
    context.user_data.clear()
    return ConversationHandler.END

async def select_service_platform(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    platform_name_raw = query.data.replace('add_service_platform_', '')
    platform_name = platform_name_raw.split(' ')[-1] if ' ' in platform_name_raw else platform_name_raw

    context.user_data['current_platform'] = platform_name
    try:
        await query.edit_message_text(f"á¢áŸ’á“á€á”á¶á“á‡áŸ’ášá¾áŸášá¾áŸ Platform **{platform_name}** áŸ”\n\ná¥á¡á¼áœáŸá¼á˜áœá¶á™á”á‰áŸ’á…á¼á›áˆáŸ’á˜áŸ„áŸ‡áŸáŸáœá¶á€á˜áŸ’á˜ááŸ’á˜á¸áŸ– (á§á‘á¶á ášááŸáŸ– `Facebook Likes`)\n\náœá¶á™ /cancel áŠá¾á˜áŸ’á”á¸á”áŸ„áŸ‡á”á„áŸ‹áŸ”", parse_mode='Markdown')
    except BadRequest:
        await context.bot.send_message(chat_id=update.effective_chat.id, text=f"á¢áŸ’á“á€á”á¶á“á‡áŸ’ášá¾áŸášá¾áŸ Platform **{platform_name}** áŸ”\n\ná¥á¡á¼áœáŸá¼á˜áœá¶á™á”á‰áŸ’á…á¼á›áˆáŸ’á˜áŸ„áŸ‡áŸáŸáœá¶á€á˜áŸ’á˜ááŸ’á˜á¸áŸ– (á§á‘á¶á ášááŸáŸ– `Facebook Likes`)\n\náœá¶á™ /cancel áŠá¾á˜áŸ’á”á¸á”áŸ„áŸ‡á”á„áŸ‹áŸ”", parse_mode='Markdown')
    return ADD_SERVICE_NAME

async def received_service_name(update: Update, context: ContextTypes.DEFAULT_TYPE):
    service_name = update.message.text.strip()
    platform_name = context.user_data.get('current_platform')

    if not platform_name:
        await update.message.reply_text("á˜á¶á“á”á‰áŸ’á á¶áŸ” áŸá¼á˜á…á¶á”áŸ‹á•áŸ’áá¾á˜á¡á¾á„áœá·á‰á–á¸ /admin áŸ”", parse_mode='Markdown')
        context.user_data.clear()
        return ConversationHandler.END

    base_service_id = "".join(filter(str.isalnum, service_name.lower().replace(' ', '_')))
    service_id = base_service_id
    counter = 1
    existing_ids = {s['id'] for s in services_data.get(platform_name, [])}
    while service_id in existing_ids:
        service_id = f"{base_service_id}_{counter}"
        counter += 1

    if any(s['name'].lower() == service_name.lower() for s in services_data.get(platform_name, [])):
        await update.message.reply_text(f"áŸáŸáœá¶á€á˜áŸ’á˜ '**{service_name}**' á˜á¶á“ášá½á…á á¾á™áŸ” áŸá¼á˜áœá¶á™áˆáŸ’á˜áŸ„áŸ‡á•áŸ’áŸáŸá„ á¬ /cancel áŸ”", parse_mode='Markdown')
        return ADD_SERVICE_NAME

    context.user_data['new_service_id'] = service_id
    context.user_data['new_service_name'] = service_name
    await update.message.reply_text("á¥á¡á¼áœáŸá¼á˜áœá¶á™á”á‰áŸ’á…á¼á›áá˜áŸ’á›áŸƒáŸá˜áŸ’ášá¶á”áŸ‹áŸáŸáœá¶á€á˜áŸ’á˜á“áŸáŸ‡ (áá˜áŸ’á›áŸƒá‚á·áá‡á¶ $ á€áŸ’á“á»á„ 1000)ï¼š (á§. `5.0`)\n\náœá¶á™ /cancel áŠá¾á˜áŸ’á”á¸á”áŸ„áŸ‡á”á„áŸ‹áŸ”", parse_mode='Markdown')
    return ADD_SERVICE_PRICE

async def received_service_price_and_ask_smm_id(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        service_price_per_k = float(update.message.text.strip())
        if service_price_per_k < 0: raise ValueError("Price cannot be negative.")
    except ValueError:
        await update.message.reply_text("áá˜áŸ’á›áŸƒá˜á·á“ááŸ’ášá¹á˜ááŸ’ášá¼áœá‘áŸáŸ” áŸá¼á˜áœá¶á™á”á‰áŸ’á…á¼á›á‡á¶á›áŸá (á§. `5.0`) á¬ /cancel áŸ”", parse_mode='Markdown')
        return ADD_SERVICE_PRICE

    context.user_data['new_service_price_per_k'] = service_price_per_k
    await update.message.reply_text("á¥á¡á¼áœáŸá¼á˜áœá¶á™á”á‰áŸ’á…á¼á› **SMM Service ID** áŸá˜áŸ’ášá¶á”áŸ‹áŸáŸáœá¶á€á˜áŸ’á˜á“áŸáŸ‡áŸ– (á§. `12345`)\n\náœá¶á™ /cancel áŠá¾á˜áŸ’á”á¸á”áŸ„áŸ‡á”á„áŸ‹áŸ”", parse_mode='Markdown')
    return ADD_SMM_SERVICE_ID

async def received_smm_service_id(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        smm_service_id = int(update.message.text.strip())
        if smm_service_id <= 0: raise ValueError("SMM Service ID must be a positive integer.")
    except ValueError:
        await update.message.reply_text("SMM Service ID á˜á·á“ááŸ’ášá¹á˜ááŸ’ášá¼áœá‘áŸáŸ” áŸá¼á˜áœá¶á™á”á‰áŸ’á…á¼á›á‡á¶á›áŸá (á§. `12345`) á¬ /canceláŸ”", parse_mode='Markdown')
        return ADD_SMM_SERVICE_ID

    platform_name = context.user_data.get('current_platform')
    new_service_name = context.user_data.get('new_service_name')
    new_service_id = context.user_data.get('new_service_id')
    service_price_per_k = context.user_data.get('new_service_price_per_k')

    if not all([platform_name, new_service_name, new_service_id, service_price_per_k is not None]):
        await update.message.reply_text("á˜á¶á“á”á‰áŸ’á á¶áŸ” áŸá¼á˜á…á¶á”áŸ‹á•áŸ’áá¾á˜á¡á¾á„áœá·á‰á–á¸ /admin áŸ”", parse_mode='Markdown')
        context.user_data.clear()
        return ConversationHandler.END

    services_data[platform_name].append({
        "id": new_service_id,
        "name": new_service_name,
        "price_per_k": service_price_per_k,
        "smm_service_id": smm_service_id
    })
    await update.message.reply_text(f"âœ… á”á¶á“á”á“áŸ’ááŸ‚á˜áŸáŸáœá¶á€á˜áŸ’á˜ **'{new_service_name}'** á‘áŸ…á€á¶á“áŸ‹ **{platform_name}** áŠáŸ„á™á‡áŸ„á‚á‡áŸá™áŸ”\n\n/admin áŠá¾á˜áŸ’á”á¸ááŸ’ášá¡á”áŸ‹á‘áŸ… Admin Panel áœá·á‰áŸ”", parse_mode='Markdown')

    context.user_data.clear()
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Cancels and ends the current conversation, returning to the main menu."""
    reply_text = "âŒ á”á¶á“á”áŸ„áŸ‡á”á„áŸ‹á”áŸ’ášáá·á”ááŸ’áá·á€á¶ášáŸ”"
    chat_id_to_send = update.effective_chat.id

    if update.callback_query:
        await update.callback_query.answer()
        try:
            await update.callback_query.message.edit_text(text=reply_text, parse_mode='Markdown')
        except BadRequest:
            await context.bot.send_message(chat_id=chat_id_to_send, text=reply_text, parse_mode='Markdown')
    elif update.message:
        await update.message.reply_text(text=reply_text, parse_mode='Markdown')

    await context.bot.send_message(
        chat_id=chat_id_to_send,
        text="áŸá¼á˜á‡áŸ’ášá¾áŸášá¾áŸá‡á˜áŸ’ášá¾áŸáá¶á„á€áŸ’ášáŸ„á˜áŸ–",
        reply_markup=await get_main_menu_keyboard(),
        parse_mode='Markdown'
    )
    context.user_data.clear()
    return ConversationHandler.END

async def confirm_delete_all_services_action(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    if update.effective_user.id not in ADMIN_USER_IDS:
        try:
            await query.edit_message_text("â›”ï¸ á¢áŸ’á“á€á˜á·á“á˜á¶á“áŸá·á‘áŸ’á’á·á…á¼á›á”áŸ’ášá¾á˜á»áá„á¶ášá“áŸáŸ‡á‘áŸáŸ”", parse_mode='Markdown')
        except BadRequest:
            await context.bot.send_message(chat_id=update.effective_chat.id, text="â›”ï¸ á¢áŸ’á“á€á˜á·á“á˜á¶á“áŸá·á‘áŸ’á’á·á…á¼á›á”áŸ’ášá¾á˜á»áá„á¶ášá“áŸáŸ‡á‘áŸáŸ”", parse_mode='Markdown')
        return ConversationHandler.END

    if query.data == 'confirm_delete_all_yes':
        global services_data
        for platform in services_data:
            services_data[platform] = []
        try:
            await query.edit_message_text("ğŸ—‘ï¸ **á”á¶á“á›á»á”áŸáŸáœá¶á€á˜áŸ’á˜á‘á¶áŸ†á„á¢áŸáŸ‹á…áŸá‰á–á¸á”áŸ’ášá–áŸá“áŸ’á’á á¾á™!**\n\n/admin", parse_mode='Markdown')
        except BadRequest:
            await context.bot.send_message(chat_id=update.effective_chat.id, text="ğŸ—‘ï¸ **á”á¶á“á›á»á”áŸáŸáœá¶á€á˜áŸ’á˜á‘á¶áŸ†á„á¢áŸáŸ‹á…áŸá‰á–á¸á”áŸ’ášá–áŸá“áŸ’á’á á¾á™!**\n\n/admin", parse_mode='Markdown')
    else:
        try:
            await query.edit_message_text("âŒ á€á¶ášá›á»á”áŸáŸáœá¶á€á˜áŸ’á˜á‘á¶áŸ†á„á¢áŸáŸ‹ááŸ’ášá¼áœá”á¶á“á”áŸ„áŸ‡á”á„áŸ‹áŸ”\n\n/admin", parse_mode='Markdown')
        except BadRequest:
            await context.bot.send_message(chat_id=update.effective_chat.id, text="âŒ á€á¶ášá›á»á”áŸáŸáœá¶á€á˜áŸ’á˜á‘á¶áŸ†á„á¢áŸáŸ‹ááŸ’ášá¼áœá”á¶á“á”áŸ„áŸ‡á”á„áŸ‹áŸ”\n\n/admin", parse_mode='Markdown')
    context.user_data.clear()
    return ConversationHandler.END

async def received_old_platform_name(update: Update, context: ContextTypes.DEFAULT_TYPE):
    old_name = update.message.text.strip()
    if old_name not in services_data:
        await update.message.reply_text(f"Platform '**{old_name}**' á˜á·á“á˜á¶á“á‘áŸáŸ” áŸá¼á˜áœá¶á™áˆáŸ’á˜áŸ„áŸ‡á˜áŸ’áá„á‘áŸ€á á¬ /cancel áŸ”", parse_mode='Markdown')
        return RENAME_PLATFORM_OLD_NAME
    context.user_data['old_platform_name'] = old_name
    await update.message.reply_text(f"á¢áŸ’á“á€á”á¶á“á‡áŸ’ášá¾áŸášá¾áŸ **{old_name}** áŸ”\n\ná¥á¡á¼áœáŸá¼á˜áœá¶á™á”á‰áŸ’á…á¼á›áˆáŸ’á˜áŸ„áŸ‡ááŸ’á˜á¸áŸ–", parse_mode='Markdown')
    return RENAME_PLATFORM_NEW_NAME

async def finalize_rename_platform(update: Update, context: ContextTypes.DEFAULT_TYPE):
    new_name = update.message.text.strip()
    old_name = context.user_data.get('old_platform_name')
    if not old_name:
        await update.message.reply_text("á˜á¶á“á”á‰áŸ’á á¶áŸ” áŸá¼á˜á…á¶á”áŸ‹á•áŸ’áá¾á˜á¡á¾á„áœá·á‰á–á¸ /admin áŸ”", parse_mode='Markdown')
        context.user_data.clear()
        return ConversationHandler.END
    if new_name.lower() in [key.lower() for key in services_data.keys()]:
        await update.message.reply_text(f"áˆáŸ’á˜áŸ„áŸ‡ Platform '**{new_name}**' á˜á¶á“ášá½á…á á¾á™áŸ” áŸá¼á˜áœá¶á™áˆáŸ’á˜áŸ„áŸ‡á•áŸ’áŸáŸá„ á¬ /cancel áŸ”", parse_mode='Markdown')
        return RENAME_PLATFORM_NEW_NAME
    
    new_name_clean = new_name.split(' ')[-1] if ' ' in new_name else new_name
    
    services_data[new_name_clean] = services_data.pop(old_name)
    await update.message.reply_text(f"âœ… á”á¶á“á€áŸ‚á”áŸ’ášáŸ‚áˆáŸ’á˜áŸ„áŸ‡ Platform á–á¸ **'{old_name}'** á‘áŸ… **'{new_name_clean}'** áŠáŸ„á™á‡áŸ„á‚á‡áŸá™áŸ”\n\n/admin áŠá¾á˜áŸ’á”á¸ááŸ’ášá¡á”áŸ‹á‘áŸ… Admin Panel áœá·á‰áŸ”", parse_mode='Markdown')
    context.user_data.clear()
    return ConversationHandler.END

async def admin_deposit_by_id_entry(update: Update, context: ContextTypes.DEFAULT_TYPE): # Renamed to _entry
    query = update.callback_query
    await query.answer()
    if update.effective_user.id not in ADMIN_USER_IDS: # Added admin check
        await send_or_edit_message_from_query(query, "â›”ï¸ á¢áŸ’á“á€á˜á·á“á˜á¶á“áŸá·á‘áŸ’á’á·á…á¼á›á”áŸ’ášá¾ Admin Panel á‘áŸáŸ”")
        return ConversationHandler.END
    
    try:
        await query.edit_message_text("áŸá¼á˜áœá¶á™á”á‰áŸ’á…á¼á› **User ID** áŠáŸ‚á›á¢áŸ’á“á€á…á„áŸ‹áŠá¶á€áŸ‹á”áŸ’ášá¶á€áŸ‹áŸ–\n\náœá¶á™ /cancel áŠá¾á˜áŸ’á”á¸á”áŸ„áŸ‡á”á„áŸ‹áŸ”", parse_mode='Markdown')
    except BadRequest:
        await context.bot.send_message(chat_id=update.effective_chat.id, text="áŸá¼á˜áœá¶á™á”á‰áŸ’á…á¼á› **User ID** áŠáŸ‚á›á¢áŸ’á“á€á…á„áŸ‹áŠá¶á€áŸ‹á”áŸ’ášá¶á€áŸ‹áŸ–\n\náœá¶á™ /cancel áŠá¾á˜áŸ’á”á¸á”áŸ„áŸ‡á”á„áŸ‹áŸ”", parse_mode='Markdown')
    return ASK_USER_ID_FOR_DEPOSIT

async def receive_user_id_for_deposit(update: Update, context: ContextTypes.DEFAULT_TYPE): 
    try:
        target_user_id = int(update.message.text.strip())
        context.user_data['target_user_id'] = target_user_id
        await update.message.reply_text(f"User ID: `{target_user_id}` áŸ”\n\ná¥á¡á¼áœáŸá¼á˜áœá¶á™á”á‰áŸ’á…á¼á› **á…áŸ†á“á½á“á‘á¹á€á”áŸ’ášá¶á€áŸ‹**áŸ– (á§. `10.50`)\n\náœá¶á™ /cancel áŸ”", parse_mode='Markdown')
    except ValueError:
        await update.message.reply_text("User ID á˜á·á“ááŸ’ášá¹á˜ááŸ’ášá¼áœáŸ” áŸá¼á˜áœá¶á™á”á‰áŸ’á…á¼á›á‡á¶á›áŸá á¬ /cancel áŸ”", parse_mode='Markdown')
        return ASK_USER_ID_FOR_DEPOSIT
    return ASK_AMOUNT_FOR_DEPOSIT

async def receive_amount_for_deposit(update: Update, context: ContextTypes.DEFAULT_TYPE): 
    try:
        amount = float(update.message.text.strip())
        if amount <= 0: raise ValueError("Amount must be positive.")
    except ValueError:
        await update.message.reply_text("á…áŸ†á“á½á“á‘á¹á€á”áŸ’ášá¶á€áŸ‹á˜á·á“ááŸ’ášá¹á˜ááŸ’ášá¼áœáŸ” áŸá¼á˜áœá¶á™á”á‰áŸ’á…á¼á›á‡á¶á›áŸá (á§. `10.50`) á¬ /cancel áŸ”", parse_mode='Markdown')
        return ASK_AMOUNT_FOR_DEPOSIT
    target_user_id = context.user_data.get('target_user_id')
    if target_user_id is None:
        await update.message.reply_text("á˜á¶á“á”á‰áŸ’á á¶áŸ” áŸá¼á˜á…á¶á”áŸ‹á•áŸ’áá¾á˜á¡á¾á„áœá·á‰áŸ”", parse_mode='Markdown')
        context.user_data.clear()
        return ConversationHandler.END
    if target_user_id not in user_accounts:
        user_accounts[target_user_id] = {"balance": 0, "transactions": [], "orders": []}
    user_accounts[target_user_id]["balance"] += amount
    user_accounts[target_user_id]["transactions"].append(f"+{amount:.2f}$ (Admin add) on {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    await update.message.reply_text(f"âœ… á”á¶á“áŠá¶á€áŸ‹á”áŸ’ášá¶á€áŸ‹ **{amount:.2f}$** á‘áŸ…á€á¶á“áŸ‹ User ID: **{target_user_id}**áŸ” á‘á¹á€á”áŸ’ášá¶á€áŸ‹áŸášá»á”: **{user_accounts[target_user_id]['balance']:.2f}$**\n\n/admin", parse_mode='Markdown')
    try:
        await context.bot.send_message(chat_id=target_user_id, text=f"ğŸ‰ á‘á¹á€á”áŸ’ášá¶á€áŸ‹ **{amount:.2f}$** ááŸ’ášá¼áœá”á¶á“á”á“áŸ’ááŸ‚á˜á‘áŸ…á‚áá“á¸ášá”áŸáŸ‹á¢áŸ’á“á€áŸ” á‘á¹á€á”áŸ’ášá¶á€áŸ‹áŸášá»á”: **{user_accounts[target_user_id]['balance']:.2f}$**", parse_mode='Markdown')
    except TelegramError as e: 
        logger.warning(f"Failed to notify user {target_user_id} about balance addition: {e}")
    context.user_data.clear()
    return ConversationHandler.END

async def check_smm_balance_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    if user_id not in ADMIN_USER_IDS:
        if update.callback_query: 
            await update.callback_query.answer("â›”ï¸ á¢áŸ’á“á€á˜á·á“á˜á¶á“áŸá·á‘áŸ’á’á·áŸ”", show_alert=True)
            try:
                await update.callback_query.message.edit_text("â›”ï¸ á¢áŸ’á“á€á˜á·á“á˜á¶á“áŸá·á‘áŸ’á’á·áŸ”", parse_mode='Markdown')
            except BadRequest:
                await context.bot.send_message(chat_id=update.effective_chat.id, text="â›”ï¸ á¢áŸ’á“á€á˜á·á“á˜á¶á“áŸá·á‘áŸ’á’á·áŸ”", parse_mode='Markdown')
        else: 
            await update.message.reply_text("â›”ï¸ á¢áŸ’á“á€á˜á·á“á˜á¶á“áŸá·á‘áŸ’á’á·áŸ”", parse_mode='Markdown')
        return ConversationHandler.END 
    
    target_message = update.callback_query.message if update.callback_query else update.message
    try:
        await target_message.edit_text("ğŸ’² á€áŸ†á–á»á„á†áŸ‚á€á‘á¹á€á”áŸ’ášá¶á€áŸ‹ SMM Panel...", parse_mode='Markdown')
    except BadRequest:
        await context.bot.send_message(chat_id=update.effective_chat.id, text="ğŸ’² á€áŸ†á–á»á„á†áŸ‚á€á‘á¹á€á”áŸ’ášá¶á€áŸ‹ SMM Panel...", parse_mode='Markdown')

    response = await smm_client.get_balance()
    if response.get("success"):
        try:
            await target_message.edit_text(f"âœ… á‘á¹á€á”áŸ’ášá¶á€áŸ‹á€áŸ’á“á»á„ SMM PaneláŸ– **{response['balance']:.2f} {response.get('currency', 'USD')}**\n\n/admin", parse_mode='Markdown')
        except BadRequest:
            await context.bot.send_message(chat_id=update.effective_chat.id, text=f"âœ… á‘á¹á€á”áŸ’ášá¶á€áŸ‹á€áŸ’á“á»á„ SMM PaneláŸ– **{response['balance']:.2f} {response.get('currency', 'USD')}**\n\n/admin", parse_mode='Markdown')
    else:
        try:
            await target_message.edit_text(f"âŒ á˜á·á“á¢á¶á…á†áŸ‚á€á‘á¹á€á”áŸ’ášá¶á€áŸ‹á”á¶á“á‘áŸáŸ” á”á‰áŸ’á á¶: `{response.get('error', 'Unknown')}`\n\n/admin", parse_mode='Markdown')
        except BadRequest:
            await context.bot.send_message(chat_id=update.effective_chat.id, text=f"âŒ á˜á·á“á¢á¶á…á†áŸ‚á€á‘á¹á€á”áŸ’ášá¶á€áŸ‹á”á¶á“á‘áŸáŸ” á”á‰áŸ’á á¶: `{response.get('error', 'Unknown')}`\n\n/admin", parse_mode='Markdown')
    return ConversationHandler.END

async def deduct_balance_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    if user_id not in ADMIN_USER_IDS:
        await update.message.reply_text("â›”ï¸ á¢áŸ’á“á€á˜á·á“á˜á¶á“áŸá·á‘áŸ’á’á·áŸ”", parse_mode='Markdown')
        return

    if len(context.args) != 2:
        await update.message.reply_text("âš ï¸ ášá”áŸ€á”á”áŸ’ášá¾á”áŸ’ášá¶áŸáŸ‹ááŸ’ášá¹á˜ááŸ’ášá¼áœ: `/deductbalance <UserID> <Amount>`", parse_mode='Markdown')
        return

    try:
        target_user_id = int(context.args[0])
        amount = float(context.args[1])
        if amount <= 0:
            raise ValueError("Amount must be positive.")
    except (ValueError, TypeError):
        await update.message.reply_text("âŒ User ID á¬á…áŸ†á“á½á“á‘á¹á€á”áŸ’ášá¶á€áŸ‹á˜á·á“ááŸ’ášá¹á˜ááŸ’ášá¼áœáŸ” áŸá¼á˜á”á‰áŸ’á…á¼á›á›áŸáááŸ’ášá¹á˜ááŸ’ášá¼áœáŸ”", parse_mode='Markdown')
        return

    if target_user_id not in user_accounts or user_accounts[target_user_id]["balance"] < amount:
        await update.message.reply_text(f"âŒ User ID `{target_user_id}` á˜á·á“á˜á¶á“ á¬á‘á¹á€á”áŸ’ášá¶á€áŸ‹á˜á·á“á‚áŸ’ášá”áŸ‹á‚áŸ’ášá¶á“áŸ‹áŸ” á‘á¹á€á”áŸ’ášá¶á€áŸ‹á”á…áŸ’á…á»á”áŸ’á”á“áŸ’á“: `{user_accounts.get(target_user_id, {}).get('balance', 0):.2f}$`", parse_mode='Markdown')
        return

    user_accounts[target_user_id]["balance"] -= amount
    user_accounts[target_user_id]["transactions"].append(f"-{amount:.2f}$ (Admin deduct) on {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    new_balance = user_accounts[target_user_id]['balance']

    await update.message.reply_text(f"âœ… á”á¶á“á€á¶ááŸ‹á”á“áŸ’áá™á‘á¹á€á”áŸ’ášá¶á€áŸ‹ **{amount:.2f}$** á–á¸ User ID: **{target_user_id}**áŸ” á‘á¹á€á”áŸ’ášá¶á€áŸ‹áŸášá»á”: **{new_balance:.2f}$**", parse_mode='Markdown')
    try:
        await context.bot.send_message(chat_id=target_user_id, text=f"âš ï¸ á‘á¹á€á”áŸ’ášá¶á€áŸ‹ **{amount:.2f}$** ááŸ’ášá¼áœá”á¶á“á€á¶ááŸ‹á…áŸá‰á–á¸á‚áá“á¸ášá”áŸáŸ‹á¢áŸ’á“á€áŠáŸ„á™á¢áŸ’á“á€á‚áŸ’ášá”áŸ‹á‚áŸ’ášá„áŸ” á‘á¹á€á”áŸ’ášá¶á€áŸ‹áŸášá»á”: **{new_balance:.2f}$**", parse_mode='Markdown')
    except TelegramError as e:
        logger.warning(f"Failed to notify user {target_user_id} about balance deduction: {e}")

async def edit_service_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    if user_id not in ADMIN_USER_IDS:
        await update.message.reply_text("â›”ï¸ á¢áŸ’á“á€á˜á·á“á˜á¶á“áŸá·á‘áŸ’á’á·áŸ”", parse_mode='Markdown')
        return

    if len(context.args) != 5:
        await update.message.reply_text("âš ï¸ ášá”áŸ€á”á”áŸ’ášá¾á”áŸ’ášá¶áŸáŸ‹ááŸ’ášá¹á˜ááŸ’ášá¼áœ: `/editservice <Platform> <Service ID> <New Service Name> <New Price Per 1K> <New SMM Service ID>`", parse_mode='Markdown')
        return

    platform_name = context.args[0]
    service_id_to_edit = context.args[1]
    new_service_name = context.args[2]
    
    try:
        new_price_per_k = float(context.args[3])
        new_smm_service_id = int(context.args[4])
        if new_price_per_k < 0 or new_smm_service_id <= 0:
            raise ValueError("Price and SMM Service ID must be positive.")
    except (ValueError, TypeError):
        await update.message.reply_text("âŒ áá˜áŸ’á›áŸƒ á¬ SMM Service ID á˜á·á“ááŸ’ášá¹á˜ááŸ’ášá¼áœáŸ” áŸá¼á˜á”á‰áŸ’á…á¼á›á›áŸáááŸ’ášá¹á˜ááŸ’ášá¼áœáŸ”", parse_mode='Markdown')
        return

    if platform_name not in services_data:
        await update.message.reply_text(f"âŒ Platform '**{platform_name}**' á˜á·á“á˜á¶á“á‘áŸáŸ”", parse_mode='Markdown')
        return

    service_found = False
    for service in services_data[platform_name]:
        if service['id'] == service_id_to_edit:
            service['name'] = new_service_name
            service['price_per_k'] = new_price_per_k
            service['smm_service_id'] = new_smm_service_id
            service_found = True
            break
    
    if service_found:
        await update.message.reply_text(f"âœ… á”á¶á“á€áŸ‚á”áŸ’ášáŸ‚áŸáŸáœá¶á€á˜áŸ’á˜ `{service_id_to_edit}` á€áŸ’á“á»á„ Platform **{platform_name}** áŠáŸ„á™á‡áŸ„á‚á‡áŸá™áŸ”", parse_mode='Markdown')
    else:
        await update.message.reply_text(f"âŒ á˜á·á“á¢á¶á…ášá€áƒá¾á‰áŸáŸáœá¶á€á˜áŸ’á˜ `{service_id_to_edit}` á€áŸ’á“á»á„ Platform **{platform_name}** á‘áŸáŸ”", parse_mode='Markdown')

async def delete_single_service_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    if user_id not in ADMIN_USER_IDS:
        await update.message.reply_text("â›”ï¸ á¢áŸ’á“á€á˜á·á“á˜á¶á“áŸá·á‘áŸ’á’á·áŸ”", parse_mode='Markdown')
        return

    if len(context.args) != 2:
        await update.message.reply_text("âš ï¸ ášá”áŸ€á”á”áŸ’ášá¾á”áŸ’ášá¶áŸáŸ‹ááŸ’ášá¹á˜ááŸ’ášá¼áœ: `/deleteservice <Platform> <Service ID>`", parse_mode='Markdown')
        return

    platform_name = context.args[0]
    service_id_to_delete = context.args[1]

    if platform_name not in services_data:
        await update.message.reply_text(f"âŒ Platform '**{platform_name}**' á˜á·á“á˜á¶á“á‘áŸáŸ”", parse_mode='Markdown')
        return

    initial_service_count = len(services_data[platform_name])
    services_data[platform_name] = [s for s in services_data[platform_name] if s['id'] != service_id_to_delete]
    
    if len(services_data[platform_name]) < initial_service_count:
        await update.message.reply_text(f"âœ… á”á¶á“á›á»á”áŸáŸáœá¶á€á˜áŸ’á˜ `{service_id_to_delete}` á…áŸá‰á–á¸ Platform **{platform_name}** áŠáŸ„á™á‡áŸ„á‚á‡áŸá™áŸ”", parse_mode='Markdown')
    else:
        await update.message.reply_text(f"âŒ á˜á·á“á¢á¶á…ášá€áƒá¾á‰áŸáŸáœá¶á€á˜áŸ’á˜ `{service_id_to_delete}` á€áŸ’á“á»á„ Platform **{platform_name}** á‘áŸáŸ”", parse_mode='Markdown')

async def broadcast_message_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    if user_id not in ADMIN_USER_IDS:
        await update.message.reply_text("â›”ï¸ á¢áŸ’á“á€á˜á·á“á˜á¶á“áŸá·á‘áŸ’á’á·áŸ”", parse_mode='Markdown')
        return

    if not context.args:
        await update.message.reply_text("âš ï¸ ášá”áŸ€á”á”áŸ’ášá¾á”áŸ’ášá¶áŸáŸ‹ááŸ’ášá¹á˜ááŸ’ášá¼áœ: `/broadcast <Your Message>`", parse_mode='Markdown')
        return

    message_to_send = " ".join(context.args)
    sent_count = 0
    failed_count = 0

    await update.message.reply_text("ğŸ“¢ á€áŸ†á–á»á„á•áŸ’á‰á¾áŸá¶áš Broadcast... áŸá¼á˜ášá„áŸ‹á…á¶áŸ†áŸ”", parse_mode='Markdown')

    for uid in user_accounts.keys():
        if uid == user_id: 
            continue
        try:
            await context.bot.send_message(chat_id=uid, text=f"ğŸ”” **áŸá¶ášá–á¸á¢áŸ’á“á€á‚áŸ’ášá”áŸ‹á‚áŸ’ášá„:**\n\n{message_to_send}", parse_mode='Markdown')
            sent_count += 1
        except TelegramError as e:
            logger.warning(f"Failed to send broadcast to user {uid}. Error: {e}")
            failed_count += 1
    
    await update.message.reply_text(f"âœ… á”á¶á“á•áŸ’á‰á¾áŸá¶áš Broadcast ášá½á…ášá¶á›áŸ‹áŸ”\n"
                                     f"ğŸ‘‰ **á”á¶á“á•áŸ’á‰á¾á‘áŸ…:** {sent_count} á“á¶á€áŸ‹\n"
                                     f"ğŸ‘‰ **á”ášá¶á‡áŸá™:** {failed_count} á“á¶á€áŸ‹", parse_mode='Markdown')


def main():
    """á…á¶á”áŸ‹á•áŸ’áá¾á˜ Bot áŸ”"""
    application = Application.builder().token("8086248274:AAFT1YgdZT3Dvl3IOwU_Ca0PWQvTnWzAaKQ").build()

    job_queue = application.job_queue
    application.bot_data['pending_deposits'] = {}  

    # --- Handlers ---

    # 1. Conversation Handler áŸá˜áŸ’ášá¶á”áŸ‹á€á¶ášáŠá¶á€áŸ‹á”áŸ’ášá¶á€áŸ‹
    deposit_conv_handler = ConversationHandler(
        entry_points=[MessageHandler(filters.Text([BTN_DEPOSIT]), start_deposit)],
        states={
            DEPOSIT_AMOUNT: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_deposit_amount)],
        },
        fallbacks=[CommandHandler('cancel', cancel), CommandHandler("start", start)], 
        per_user=True,
        per_chat=True,
        allow_reentry=True
    )
    application.add_handler(deposit_conv_handler)

    # 2. Conversation Handler áŸá˜áŸ’ášá¶á”áŸ‹á€á¶ášá”á‰áŸ’á‡á¶á‘á·á‰
    user_order_conv_handler = ConversationHandler(
        entry_points=[CallbackQueryHandler(select_service_to_buy, pattern='^buy_service_.*$')],
        states={
            RECEIVE_QUANTITY: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_quantity_then_ask_link)],
            RECEIVE_LINK: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_link_and_confirm_order)],
            CONFIRM_ORDER_AND_PAY: [CallbackQueryHandler(process_and_deduct_balance, pattern='^(confirm_order|cancel_order)$')],
        },
        fallbacks=[CommandHandler("cancel", cancel_order_flow), CommandHandler("start", start)],
        allow_reentry=True
    )
    application.add_handler(user_order_conv_handler)

    # 3. Handler áŸá˜áŸ’ášá¶á”áŸ‹ Command /start
    application.add_handler(CommandHandler("start", start))

    # 4. Handler áŸá˜áŸ’ášá¶á”áŸ‹á”áŸŠá¼áá»á„ Menu àº«àº¼á¶á€áŸ‹ & Platform Buttons (User-facing)
    all_reply_buttons = [
        BTN_ORDER, BTN_DEPOSIT, BTN_BALANCE, BTN_USER_ID, BTN_CONTACT, BTN_HISTORY,
        BTN_TIKTOK_PLATFORM, BTN_YOUTUBE_PLATFORM, BTN_FACEBOOK_PLATFORM, 
        BTN_TWITTER_PLATFORM, BTN_TELEGRAM_PLATFORM, BTN_INSTAGRAM_PLATFORM,
        BTN_HOW_TO_BUY, BTN_JOIN_CHANNEL, BTN_ADMIN_CHAT, BTN_BACK_TO_MAIN_MENU
    ]
    application.add_handler(MessageHandler(filters.Text(all_reply_buttons), main_menu_handler))
    
    # 5. Handler áŸá˜áŸ’ášá¶á”áŸ‹ CallbackQuery áŠáŸ‚á›á“áŸ…áŸá›áŸ‹ (áŸá˜áŸ’ášá¶á”áŸ‹ user menu)
    application.add_handler(CallbackQueryHandler(button_handler, pattern='^(show_services_.*|start_menu|show_platform_menu_from_inline)$'))

    # 6. Handler áŸá˜áŸ’ášá¶á”áŸ‹ Admin á”á‰áŸ’á‡á¶á€áŸ‹á€á¶ášáŠá¶á€áŸ‹á”áŸ’ášá¶á€áŸ‹
    application.add_handler(CallbackQueryHandler(handle_deposit_confirmation, pattern='^deposit_(approve|reject)_.*$'))

    # --- Admin Handlers ---
    application.add_handler(CommandHandler("admin", admin_panel)) # Main admin command

    # CONVERSATION HANDLER FOR ADMIN SERVICE AND PLATFORM MANAGEMENT
    admin_manage_service_conv_handler = ConversationHandler(
        entry_points=[
            # Direct entry points for admin actions that start a conversation flow
            CallbackQueryHandler(admin_add_platform_entry, pattern='^admin_add_platform$'),
            CallbackQueryHandler(admin_add_service_new_entry, pattern='^admin_add_service_new$'),
            CallbackQueryHandler(admin_delete_all_services_entry, pattern='^admin_delete_all_services$'),
            CallbackQueryHandler(admin_rename_platform_entry, pattern='^admin_rename_platform$'),
            CallbackQueryHandler(admin_delete_platform_select_entry, pattern='^admin_delete_platform_select$'),
        ],
        states={
            ADD_PLATFORM_NAME: [MessageHandler(filters.TEXT & ~filters.COMMAND, received_platform_name)],
            ADD_SERVICE_PLATFORM: [CallbackQueryHandler(select_service_platform, pattern='^add_service_platform_.*$')],
            ADD_SERVICE_NAME: [MessageHandler(filters.TEXT & ~filters.COMMAND, received_service_name)],
            ADD_SERVICE_PRICE: [MessageHandler(filters.TEXT & ~filters.COMMAND, received_service_price_and_ask_smm_id)],
            ADD_SMM_SERVICE_ID: [MessageHandler(filters.TEXT & ~filters.COMMAND, received_smm_service_id)],
            CONFIRM_DELETE_ALL_SERVICES: [CallbackQueryHandler(confirm_delete_all_services_action, pattern='^confirm_delete_all_.*$')],
            RENAME_PLATFORM_OLD_NAME: [MessageHandler(filters.TEXT & ~filters.COMMAND, received_old_platform_name)],
            RENAME_PLATFORM_NEW_NAME: [MessageHandler(filters.TEXT & ~filters.COMMAND, finalize_rename_platform)],
            DELETE_PLATFORM_NAME: [CallbackQueryHandler(admin_delete_platform_confirm, pattern='^delete_platform_confirm_.*$')], 
            CONFIRM_DELETE_PLATFORM: [CallbackQueryHandler(admin_delete_platform_execute, pattern='^(confirm_delete_platform_yes_|confirm_delete_platform_no)$')], 
        },
        fallbacks=[CommandHandler("cancel", cancel), CommandHandler("admin", admin_panel)], 
        per_user=True, 
        per_chat=True, 
        allow_reentry=True
    )
    application.add_handler(admin_manage_service_conv_handler)

    # CONVERSATION HANDLER FOR ADMIN DEPOSIT BY ID
    admin_deposit_conv_handler = ConversationHandler( 
        entry_points=[CallbackQueryHandler(admin_deposit_by_id_entry, pattern='^admin_deposit_by_id$')], # Direct entry
        states={
            ASK_USER_ID_FOR_DEPOSIT: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_user_id_for_deposit)],
            ASK_AMOUNT_FOR_DEPOSIT: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_amount_for_deposit)],
        },
        fallbacks=[CommandHandler("cancel", cancel), CommandHandler("admin", admin_panel)], 
        per_user=True, 
        per_chat=True, 
        allow_reentry=True
    )
    application.add_handler(admin_deposit_conv_handler)
    
    # GENERAL ADMIN BUTTON HANDLER (for buttons that don't start a conversation)
    # Exclude patterns that are now direct entry points to conversations
    application.add_handler(CallbackQueryHandler(admin_button_handler, 
                                                 pattern='^(admin_view_services|admin_manage_balance_main|admin_broadcast|admin_back_to_panel|admin_deduct_by_id|admin_smm_tools|admin_check_smm_balance|start_menu|admin_edit_service_info|admin_delete_single_service|admin_manage_platforms)$')) 
    
    # Add command handlers for admin features that require arguments
    application.add_handler(CommandHandler("deductbalance", deduct_balance_cmd))
    application.add_handler(CommandHandler("editservice", edit_service_cmd))
    application.add_handler(CommandHandler("deleteservice", delete_single_service_cmd))
    application.add_handler(CommandHandler("broadcast", broadcast_message_cmd))


    print("Bot á€áŸ†á–á»á„áŠáŸ†áá¾ášá€á¶áš...")
    application.run_polling(allowed_updates=Update.ALL_TYPES)

if __name__ == '__main__':
    main()
